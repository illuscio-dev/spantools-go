<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>http2 - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="style.css">

<script>window.initFuncs = [];</script>
<script src="jquery.js" defer></script>



<script>var goVersion = "go1.13.5";</script>
<script src="godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="godoc.588.html">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="godoc.588.html">GoDoc</a></div>
<a href="godoc.288.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6161/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package http2
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "golang.org/x/net/http2"</code></dd>
			</dl>
			<dl>
			<dd><a href="godoc.288.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="godoc.288.html#pkg-index" class="indexLink">Index</a></dd>
			
			
				<dd><a href="godoc.288.html#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package http2 implements the HTTP/2 protocol.
</p>
<p>
This package is low-level and intended to be used directly by very
few people. Most users will use it indirectly through the automatic
use by the net/http package (from Go 1.6 and later).
For use in earlier Go versions see ConfigureServer. (Transport support
requires Go 1.6 or later)
</p>
<p>
See <a href="https://http2.github.io/">https://http2.github.io/</a> for more information on HTTP/2.
</p>
<p>
See <a href="https://http2.golang.org/">https://http2.golang.org/</a> for a test server running this code.
</p>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="godoc.288.html#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="godoc.288.html#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="godoc.288.html#ConfigureServer">func ConfigureServer(s *http.Server, conf *Server) error</a></dd>
			
				
				<dd><a href="godoc.288.html#ConfigureTransport">func ConfigureTransport(t1 *http.Transport) error</a></dd>
			
			
				
				<dd><a href="godoc.288.html#ClientConn">type ClientConn</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#ClientConn.CanTakeNewRequest">func (cc *ClientConn) CanTakeNewRequest() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#ClientConn.Close">func (cc *ClientConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#ClientConn.Ping">func (cc *ClientConn) Ping(ctx context.Context) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#ClientConn.RoundTrip">func (cc *ClientConn) RoundTrip(req *http.Request) (*http.Response, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#ClientConn.Shutdown">func (cc *ClientConn) Shutdown(ctx context.Context) error</a></dd>
				
			
				
				<dd><a href="godoc.288.html#ClientConnPool">type ClientConnPool</a></dd>
				
				
			
				
				<dd><a href="godoc.288.html#ConnectionError">type ConnectionError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#ConnectionError.Error">func (e ConnectionError) Error() string</a></dd>
				
			
				
				<dd><a href="godoc.288.html#ContinuationFrame">type ContinuationFrame</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#ContinuationFrame.HeaderBlockFragment">func (f *ContinuationFrame) HeaderBlockFragment() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#ContinuationFrame.HeadersEnded">func (f *ContinuationFrame) HeadersEnded() bool</a></dd>
				
			
				
				<dd><a href="godoc.288.html#DataFrame">type DataFrame</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#DataFrame.Data">func (f *DataFrame) Data() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#DataFrame.StreamEnded">func (f *DataFrame) StreamEnded() bool</a></dd>
				
			
				
				<dd><a href="godoc.288.html#ErrCode">type ErrCode</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#ErrCode.String">func (e ErrCode) String() string</a></dd>
				
			
				
				<dd><a href="godoc.288.html#Flags">type Flags</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Flags.Has">func (f Flags) Has(v Flags) bool</a></dd>
				
			
				
				<dd><a href="godoc.288.html#Frame">type Frame</a></dd>
				
				
			
				
				<dd><a href="godoc.288.html#FrameHeader">type FrameHeader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#ReadFrameHeader">func ReadFrameHeader(r io.Reader) (FrameHeader, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#FrameHeader.Header">func (h FrameHeader) Header() FrameHeader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#FrameHeader.String">func (h FrameHeader) String() string</a></dd>
				
			
				
				<dd><a href="godoc.288.html#FrameType">type FrameType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#FrameType.String">func (t FrameType) String() string</a></dd>
				
			
				
				<dd><a href="godoc.288.html#FrameWriteRequest">type FrameWriteRequest</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#FrameWriteRequest.Consume">func (wr FrameWriteRequest) Consume(n int32) (FrameWriteRequest, FrameWriteRequest, int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#FrameWriteRequest.DataSize">func (wr FrameWriteRequest) DataSize() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#FrameWriteRequest.StreamID">func (wr FrameWriteRequest) StreamID() uint32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#FrameWriteRequest.String">func (wr FrameWriteRequest) String() string</a></dd>
				
			
				
				<dd><a href="godoc.288.html#Framer">type Framer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#NewFramer">func NewFramer(w io.Writer, r io.Reader) *Framer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.ErrorDetail">func (fr *Framer) ErrorDetail() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.ReadFrame">func (fr *Framer) ReadFrame() (Frame, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.SetMaxReadFrameSize">func (fr *Framer) SetMaxReadFrameSize(v uint32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.SetReuseFrames">func (fr *Framer) SetReuseFrames()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.WriteContinuation">func (f *Framer) WriteContinuation(streamID uint32, endHeaders bool, headerBlockFragment []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.WriteData">func (f *Framer) WriteData(streamID uint32, endStream bool, data []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.WriteDataPadded">func (f *Framer) WriteDataPadded(streamID uint32, endStream bool, data, pad []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.WriteGoAway">func (f *Framer) WriteGoAway(maxStreamID uint32, code ErrCode, debugData []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.WriteHeaders">func (f *Framer) WriteHeaders(p HeadersFrameParam) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.WritePing">func (f *Framer) WritePing(ack bool, data [8]byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.WritePriority">func (f *Framer) WritePriority(streamID uint32, p PriorityParam) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.WritePushPromise">func (f *Framer) WritePushPromise(p PushPromiseParam) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.WriteRSTStream">func (f *Framer) WriteRSTStream(streamID uint32, code ErrCode) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.WriteRawFrame">func (f *Framer) WriteRawFrame(t FrameType, flags Flags, streamID uint32, payload []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.WriteSettings">func (f *Framer) WriteSettings(settings ...Setting) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.WriteSettingsAck">func (f *Framer) WriteSettingsAck() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Framer.WriteWindowUpdate">func (f *Framer) WriteWindowUpdate(streamID, incr uint32) error</a></dd>
				
			
				
				<dd><a href="godoc.288.html#GoAwayError">type GoAwayError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#GoAwayError.Error">func (e GoAwayError) Error() string</a></dd>
				
			
				
				<dd><a href="godoc.288.html#GoAwayFrame">type GoAwayFrame</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#GoAwayFrame.DebugData">func (f *GoAwayFrame) DebugData() []byte</a></dd>
				
			
				
				<dd><a href="godoc.288.html#HeadersFrame">type HeadersFrame</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#HeadersFrame.HasPriority">func (f *HeadersFrame) HasPriority() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#HeadersFrame.HeaderBlockFragment">func (f *HeadersFrame) HeaderBlockFragment() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#HeadersFrame.HeadersEnded">func (f *HeadersFrame) HeadersEnded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#HeadersFrame.StreamEnded">func (f *HeadersFrame) StreamEnded() bool</a></dd>
				
			
				
				<dd><a href="godoc.288.html#HeadersFrameParam">type HeadersFrameParam</a></dd>
				
				
			
				
				<dd><a href="godoc.288.html#MetaHeadersFrame">type MetaHeadersFrame</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#MetaHeadersFrame.PseudoFields">func (mh *MetaHeadersFrame) PseudoFields() []hpack.HeaderField</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#MetaHeadersFrame.PseudoValue">func (mh *MetaHeadersFrame) PseudoValue(pseudo string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#MetaHeadersFrame.RegularFields">func (mh *MetaHeadersFrame) RegularFields() []hpack.HeaderField</a></dd>
				
			
				
				<dd><a href="godoc.288.html#OpenStreamOptions">type OpenStreamOptions</a></dd>
				
				
			
				
				<dd><a href="godoc.288.html#PingFrame">type PingFrame</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#PingFrame.IsAck">func (f *PingFrame) IsAck() bool</a></dd>
				
			
				
				<dd><a href="godoc.288.html#PriorityFrame">type PriorityFrame</a></dd>
				
				
			
				
				<dd><a href="godoc.288.html#PriorityParam">type PriorityParam</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#PriorityParam.IsZero">func (p PriorityParam) IsZero() bool</a></dd>
				
			
				
				<dd><a href="godoc.288.html#PriorityWriteSchedulerConfig">type PriorityWriteSchedulerConfig</a></dd>
				
				
			
				
				<dd><a href="godoc.288.html#PushPromiseFrame">type PushPromiseFrame</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#PushPromiseFrame.HeaderBlockFragment">func (f *PushPromiseFrame) HeaderBlockFragment() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#PushPromiseFrame.HeadersEnded">func (f *PushPromiseFrame) HeadersEnded() bool</a></dd>
				
			
				
				<dd><a href="godoc.288.html#PushPromiseParam">type PushPromiseParam</a></dd>
				
				
			
				
				<dd><a href="godoc.288.html#RSTStreamFrame">type RSTStreamFrame</a></dd>
				
				
			
				
				<dd><a href="godoc.288.html#RoundTripOpt">type RoundTripOpt</a></dd>
				
				
			
				
				<dd><a href="godoc.288.html#ServeConnOpts">type ServeConnOpts</a></dd>
				
				
			
				
				<dd><a href="godoc.288.html#Server">type Server</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Server.ServeConn">func (s *Server) ServeConn(c net.Conn, opts *ServeConnOpts)</a></dd>
				
			
				
				<dd><a href="godoc.288.html#Setting">type Setting</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Setting.String">func (s Setting) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Setting.Valid">func (s Setting) Valid() error</a></dd>
				
			
				
				<dd><a href="godoc.288.html#SettingID">type SettingID</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#SettingID.String">func (s SettingID) String() string</a></dd>
				
			
				
				<dd><a href="godoc.288.html#SettingsFrame">type SettingsFrame</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#SettingsFrame.ForeachSetting">func (f *SettingsFrame) ForeachSetting(fn func(Setting) error) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#SettingsFrame.HasDuplicates">func (f *SettingsFrame) HasDuplicates() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#SettingsFrame.IsAck">func (f *SettingsFrame) IsAck() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#SettingsFrame.NumSettings">func (f *SettingsFrame) NumSettings() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#SettingsFrame.Setting">func (f *SettingsFrame) Setting(i int) Setting</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#SettingsFrame.Value">func (f *SettingsFrame) Value(id SettingID) (v uint32, ok bool)</a></dd>
				
			
				
				<dd><a href="godoc.288.html#StreamError">type StreamError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#StreamError.Error">func (e StreamError) Error() string</a></dd>
				
			
				
				<dd><a href="godoc.288.html#Transport">type Transport</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Transport.CloseIdleConnections">func (t *Transport) CloseIdleConnections()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Transport.NewClientConn">func (t *Transport) NewClientConn(c net.Conn) (*ClientConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Transport.RoundTrip">func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#Transport.RoundTripOpt">func (t *Transport) RoundTripOpt(req *http.Request, opt RoundTripOpt) (*http.Response, error)</a></dd>
				
			
				
				<dd><a href="godoc.288.html#UnknownFrame">type UnknownFrame</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#UnknownFrame.Payload">func (f *UnknownFrame) Payload() []byte</a></dd>
				
			
				
				<dd><a href="godoc.288.html#WindowUpdateFrame">type WindowUpdateFrame</a></dd>
				
				
			
				
				<dd><a href="godoc.288.html#WriteScheduler">type WriteScheduler</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#NewPriorityWriteScheduler">func NewPriorityWriteScheduler(cfg *PriorityWriteSchedulerConfig) WriteScheduler</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.288.html#NewRandomWriteScheduler">func NewRandomWriteScheduler() WriteScheduler</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/ciphers.go">ciphers.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/client_conn_pool.go">client_conn_pool.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/databuffer.go">databuffer.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/errors.go">errors.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/flow.go">flow.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go">frame.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/go111.go">go111.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/gotrack.go">gotrack.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/headermap.go">headermap.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/http2.go">http2.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/pipe.go">pipe.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/server.go">server.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go">transport.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/write.go">write.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/writesched.go">writesched.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/writesched_priority.go">writesched_priority.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/net/http2/writesched_random.go">writesched_random.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				
				<pre>const (
    <span class="comment">// ClientPreface is the string that must be sent by new</span>
    <span class="comment">// connections from clients.</span>
    <span id="ClientPreface">ClientPreface</span> = &#34;PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n&#34;

    <span class="comment">// NextProtoTLS is the NPN/ALPN protocol negotiated during</span>
    <span class="comment">// HTTP/2&#39;s TLS setup.</span>
    <span id="NextProtoTLS">NextProtoTLS</span> = &#34;h2&#34;
)</pre>
			
				<p>
TrailerPrefix is a magic prefix for ResponseWriter.Header map keys
that, if present, signals that the map entry is actually for
the response trailers, and not the response headers. The prefix
is stripped after the ServeHTTP call finishes and the values are
sent in the trailers.
</p>
<p>
This mechanism is intended only for trailers that are not known
prior to the headers being written. If the set of trailers is fixed
or known before the header is written, the normal Go trailers mechanism
is preferred:
</p>
<pre><a href="https://golang.org/pkg/net/http/#ResponseWriter">https://golang.org/pkg/net/http/#ResponseWriter</a>
<a href="https://golang.org/pkg/net/http/#example_ResponseWriter_trailers">https://golang.org/pkg/net/http/#example_ResponseWriter_trailers</a>
</pre>

				<pre>const <span id="TrailerPrefix">TrailerPrefix</span> = &#34;Trailer:&#34;</pre>
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>
Push errors.
</p>

				<pre>var (
    <span id="ErrRecursivePush">ErrRecursivePush</span>    = <a href="godoc.550.html">errors</a>.<a href="godoc.550.html#New">New</a>(&#34;http2: recursive push not allowed&#34;)
    <span id="ErrPushLimitReached">ErrPushLimitReached</span> = <a href="godoc.550.html">errors</a>.<a href="godoc.550.html#New">New</a>(&#34;http2: push would exceed peer&#39;s SETTINGS_MAX_CONCURRENT_STREAMS&#34;)
)</pre>
			
				
				<pre>var <span id="DebugGoroutines">DebugGoroutines</span> = <a href="godoc.31.html">os</a>.<a href="godoc.31.html#Getenv">Getenv</a>(&#34;DEBUG_HTTP2_GOROUTINES&#34;) == &#34;1&#34;</pre>
			
				<p>
ErrFrameTooLarge is returned from Framer.ReadFrame when the peer
sends a frame that is larger than declared with SetMaxReadFrameSize.
</p>

				<pre>var <span id="ErrFrameTooLarge">ErrFrameTooLarge</span> = <a href="godoc.550.html">errors</a>.<a href="godoc.550.html#New">New</a>(&#34;http2: frame too large&#34;)</pre>
			
				
				<pre>var <span id="ErrNoCachedConn">ErrNoCachedConn</span> <a href="godoc.4.html#error">error</a> = noCachedConnError{}</pre>
			
				
				<pre>var (
    <span id="VerboseLogs">VerboseLogs</span> <a href="godoc.4.html#bool">bool</a>
)</pre>
			
		
		
			
			
			<h2 id="ConfigureServer">func <a href="http://localhost:6161/src/golang.org/x/net/http2/server.go?s=6756:6812#L205">ConfigureServer</a>
				<a class="permalink" href="godoc.288.html#ConfigureServer">&#xb6;</a>
				
				
			</h2>
			<pre>func ConfigureServer(s *<a href="godoc.16.html">http</a>.<a href="godoc.16.html#Server">Server</a>, conf *<a href="godoc.288.html#Server">Server</a>) <a href="godoc.4.html#error">error</a></pre>
			<p>
ConfigureServer adds HTTP/2 support to a net/http Server.
</p>
<p>
The configuration conf may be nil.
</p>
<p>
ConfigureServer must be called before s begins serving.
</p>

			
			

		
			
			
			<h2 id="ConfigureTransport">func <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=4191:4240#L126">ConfigureTransport</a>
				<a class="permalink" href="godoc.288.html#ConfigureTransport">&#xb6;</a>
				
				
			</h2>
			<pre>func ConfigureTransport(t1 *<a href="godoc.16.html">http</a>.<a href="godoc.16.html#Transport">Transport</a>) <a href="godoc.4.html#error">error</a></pre>
			<p>
ConfigureTransport configures a net/http HTTP/1 Transport to use HTTP/2.
It returns an error if t1 has already been HTTP/2-enabled.
</p>

			
			

		
		
			
			
			<h2 id="ClientConn">type <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=5990:7992#L189">ClientConn</a>
				<a class="permalink" href="godoc.288.html#ClientConn">&#xb6;</a>
				
				
			</h2>
			<p>
ClientConn is the state of a single HTTP/2 client connection to an
HTTP/2 server.
</p>

			<pre>type ClientConn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ClientConn.CanTakeNewRequest">func (*ClientConn) <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=22201:22247#L695">CanTakeNewRequest</a>
					<a class="permalink" href="godoc.288.html#ClientConn.CanTakeNewRequest">&#xb6;</a>
					
					
				</h3>
				<pre>func (cc *<a href="godoc.288.html#ClientConn">ClientConn</a>) CanTakeNewRequest() <a href="godoc.4.html#bool">bool</a></pre>
				<p>
CanTakeNewRequest reports whether the connection can take a new request,
meaning it has not been closed or received or sent a GOAWAY.
</p>

				
				
				
			
				
				<h3 id="ClientConn.Close">func (*ClientConn) <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=26281:26316#L842">Close</a>
					<a class="permalink" href="godoc.288.html#ClientConn.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (cc *<a href="godoc.288.html#ClientConn">ClientConn</a>) Close() <a href="godoc.4.html#error">error</a></pre>
				<p>
Close closes the client connection immediately.
</p>
<p>
In-flight requests are interrupted. For a graceful shutdown, use Shutdown instead.
</p>

				
				
				
			
				
				<h3 id="ClientConn.Ping">func (*ClientConn) <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=67507:67560#L2339">Ping</a>
					<a class="permalink" href="godoc.288.html#ClientConn.Ping">&#xb6;</a>
					
					
				</h3>
				<pre>func (cc *<a href="godoc.288.html#ClientConn">ClientConn</a>) Ping(ctx <a href="godoc.137.html">context</a>.<a href="godoc.137.html#Context">Context</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
Ping sends a PING frame to the server and waits for the ack.
</p>

				
				
				
			
				
				<h3 id="ClientConn.RoundTrip">func (*ClientConn) <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=29853:29927#L960">RoundTrip</a>
					<a class="permalink" href="godoc.288.html#ClientConn.RoundTrip">&#xb6;</a>
					
					
				</h3>
				<pre>func (cc *<a href="godoc.288.html#ClientConn">ClientConn</a>) RoundTrip(req *<a href="godoc.16.html">http</a>.<a href="godoc.16.html#Request">Request</a>) (*<a href="godoc.16.html">http</a>.<a href="godoc.16.html#Response">Response</a>, <a href="godoc.4.html#error">error</a>)</pre>
				
				
				
				
			
				
				<h3 id="ClientConn.Shutdown">func (*ClientConn) <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=24983:25040#L781">Shutdown</a>
					<a class="permalink" href="godoc.288.html#ClientConn.Shutdown">&#xb6;</a>
					
					
				</h3>
				<pre>func (cc *<a href="godoc.288.html#ClientConn">ClientConn</a>) Shutdown(ctx <a href="godoc.137.html">context</a>.<a href="godoc.137.html#Context">Context</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
Shutdown gracefully close the client connection, waiting for running streams to complete.
</p>

				
				
				
			
		
			
			
			<h2 id="ClientConnPool">type <a href="http://localhost:6161/src/golang.org/x/net/http2/client_conn_pool.go?s=332:456#L6">ClientConnPool</a>
				<a class="permalink" href="godoc.288.html#ClientConnPool">&#xb6;</a>
				
				
			</h2>
			<p>
ClientConnPool manages a pool of HTTP/2 client connections.
</p>

			<pre>type ClientConnPool interface {
    GetClientConn(req *<a href="godoc.16.html">http</a>.<a href="godoc.16.html#Request">Request</a>, addr <a href="godoc.4.html#string">string</a>) (*<a href="godoc.288.html#ClientConn">ClientConn</a>, <a href="godoc.4.html#error">error</a>)
    MarkDead(*<a href="godoc.288.html#ClientConn">ClientConn</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ConnectionError">type <a href="http://localhost:6161/src/golang.org/x/net/http2/errors.go?s=1815:1843#L48">ConnectionError</a>
				<a class="permalink" href="godoc.288.html#ConnectionError">&#xb6;</a>
				
				
			</h2>
			<p>
ConnectionError is an error that results in the termination of the
entire connection.
</p>

			<pre>type ConnectionError <a href="godoc.288.html#ErrCode">ErrCode</a></pre>

			

			

			
			
			

			

			
				
				<h3 id="ConnectionError.Error">func (ConnectionError) <a href="http://localhost:6161/src/golang.org/x/net/http2/errors.go?s=1845:1884#L50">Error</a>
					<a class="permalink" href="godoc.288.html#ConnectionError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e <a href="godoc.288.html#ConnectionError">ConnectionError</a>) Error() <a href="godoc.4.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ContinuationFrame">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=34611:34679#L1190">ContinuationFrame</a>
				<a class="permalink" href="godoc.288.html#ContinuationFrame">&#xb6;</a>
				
				
			</h2>
			<p>
A ContinuationFrame is used to continue a sequence of header block fragments.
See <a href="http://http2.github.io/http2-spec/#rfc.section.6.10">http://http2.github.io/http2-spec/#rfc.section.6.10</a>
</p>

			<pre>type ContinuationFrame struct {
    <a href="godoc.288.html#FrameHeader">FrameHeader</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ContinuationFrame.HeaderBlockFragment">func (*ContinuationFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=34915:34971#L1202">HeaderBlockFragment</a>
					<a class="permalink" href="godoc.288.html#ContinuationFrame.HeaderBlockFragment">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#ContinuationFrame">ContinuationFrame</a>) HeaderBlockFragment() []<a href="godoc.4.html#byte">byte</a></pre>
				
				
				
				
			
				
				<h3 id="ContinuationFrame.HeadersEnded">func (*ContinuationFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=35017:35064#L1207">HeadersEnded</a>
					<a class="permalink" href="godoc.288.html#ContinuationFrame.HeadersEnded">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#ContinuationFrame">ContinuationFrame</a>) HeadersEnded() <a href="godoc.4.html#bool">bool</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="DataFrame">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=16194:16245#L563">DataFrame</a>
				<a class="permalink" href="godoc.288.html#DataFrame">&#xb6;</a>
				
				
			</h2>
			<p>
A DataFrame conveys arbitrary, variable-length sequences of octets
associated with a stream.
See <a href="http://http2.github.io/http2-spec/#rfc.section.6.1">http://http2.github.io/http2-spec/#rfc.section.6.1</a>
</p>

			<pre>type DataFrame struct {
    <a href="godoc.288.html#FrameHeader">FrameHeader</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="DataFrame.Data">func (*DataFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=16533:16566#L576">Data</a>
					<a class="permalink" href="godoc.288.html#DataFrame.Data">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#DataFrame">DataFrame</a>) Data() []<a href="godoc.4.html#byte">byte</a></pre>
				<p>
Data returns the frame&#39;s data octets, not including any padding
size byte or padding suffix bytes.
The caller must not retain the returned memory past the next
call to ReadFrame.
</p>

				
				
				
			
				
				<h3 id="DataFrame.StreamEnded">func (*DataFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=16247:16285#L568">StreamEnded</a>
					<a class="permalink" href="godoc.288.html#DataFrame.StreamEnded">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#DataFrame">DataFrame</a>) StreamEnded() <a href="godoc.4.html#bool">bool</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ErrCode">type <a href="http://localhost:6161/src/golang.org/x/net/http2/errors.go?s=282:301#L3">ErrCode</a>
				<a class="permalink" href="godoc.288.html#ErrCode">&#xb6;</a>
				
				
			</h2>
			<p>
An ErrCode is an unsigned 32-bit error code as defined in the HTTP/2 spec.
</p>

			<pre>type ErrCode <a href="godoc.4.html#uint32">uint32</a></pre>

			
				
				<pre>const (
    <span id="ErrCodeNo">ErrCodeNo</span>                 <a href="godoc.288.html#ErrCode">ErrCode</a> = 0x0
    <span id="ErrCodeProtocol">ErrCodeProtocol</span>           <a href="godoc.288.html#ErrCode">ErrCode</a> = 0x1
    <span id="ErrCodeInternal">ErrCodeInternal</span>           <a href="godoc.288.html#ErrCode">ErrCode</a> = 0x2
    <span id="ErrCodeFlowControl">ErrCodeFlowControl</span>        <a href="godoc.288.html#ErrCode">ErrCode</a> = 0x3
    <span id="ErrCodeSettingsTimeout">ErrCodeSettingsTimeout</span>    <a href="godoc.288.html#ErrCode">ErrCode</a> = 0x4
    <span id="ErrCodeStreamClosed">ErrCodeStreamClosed</span>       <a href="godoc.288.html#ErrCode">ErrCode</a> = 0x5
    <span id="ErrCodeFrameSize">ErrCodeFrameSize</span>          <a href="godoc.288.html#ErrCode">ErrCode</a> = 0x6
    <span id="ErrCodeRefusedStream">ErrCodeRefusedStream</span>      <a href="godoc.288.html#ErrCode">ErrCode</a> = 0x7
    <span id="ErrCodeCancel">ErrCodeCancel</span>             <a href="godoc.288.html#ErrCode">ErrCode</a> = 0x8
    <span id="ErrCodeCompression">ErrCodeCompression</span>        <a href="godoc.288.html#ErrCode">ErrCode</a> = 0x9
    <span id="ErrCodeConnect">ErrCodeConnect</span>            <a href="godoc.288.html#ErrCode">ErrCode</a> = 0xa
    <span id="ErrCodeEnhanceYourCalm">ErrCodeEnhanceYourCalm</span>    <a href="godoc.288.html#ErrCode">ErrCode</a> = 0xb
    <span id="ErrCodeInadequateSecurity">ErrCodeInadequateSecurity</span> <a href="godoc.288.html#ErrCode">ErrCode</a> = 0xc
    <span id="ErrCodeHTTP11Required">ErrCodeHTTP11Required</span>     <a href="godoc.288.html#ErrCode">ErrCode</a> = 0xd
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="ErrCode.String">func (ErrCode) <a href="http://localhost:6161/src/golang.org/x/net/http2/errors.go?s=1579:1611#L39">String</a>
					<a class="permalink" href="godoc.288.html#ErrCode.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (e <a href="godoc.288.html#ErrCode">ErrCode</a>) String() <a href="godoc.4.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Flags">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=1511:1527#L54">Flags</a>
				<a class="permalink" href="godoc.288.html#Flags">&#xb6;</a>
				
				
			</h2>
			<p>
Flags is a bitmask of HTTP/2 flags.
The meaning of flags varies depending on the frame type.
</p>

			<pre>type Flags <a href="godoc.4.html#uint8">uint8</a></pre>

			
				<p>
Frame-specific FrameHeader flag bits.
</p>

				<pre>const (
    <span class="comment">// Data Frame</span>
    <span id="FlagDataEndStream">FlagDataEndStream</span> <a href="godoc.288.html#Flags">Flags</a> = 0x1
    <span id="FlagDataPadded">FlagDataPadded</span>    <a href="godoc.288.html#Flags">Flags</a> = 0x8

    <span class="comment">// Headers Frame</span>
    <span id="FlagHeadersEndStream">FlagHeadersEndStream</span>  <a href="godoc.288.html#Flags">Flags</a> = 0x1
    <span id="FlagHeadersEndHeaders">FlagHeadersEndHeaders</span> <a href="godoc.288.html#Flags">Flags</a> = 0x4
    <span id="FlagHeadersPadded">FlagHeadersPadded</span>     <a href="godoc.288.html#Flags">Flags</a> = 0x8
    <span id="FlagHeadersPriority">FlagHeadersPriority</span>   <a href="godoc.288.html#Flags">Flags</a> = 0x20

    <span class="comment">// Settings Frame</span>
    <span id="FlagSettingsAck">FlagSettingsAck</span> <a href="godoc.288.html#Flags">Flags</a> = 0x1

    <span class="comment">// Ping Frame</span>
    <span id="FlagPingAck">FlagPingAck</span> <a href="godoc.288.html#Flags">Flags</a> = 0x1

    <span class="comment">// Continuation Frame</span>
    <span id="FlagContinuationEndHeaders">FlagContinuationEndHeaders</span> <a href="godoc.288.html#Flags">Flags</a> = 0x4

    <span id="FlagPushPromiseEndHeaders">FlagPushPromiseEndHeaders</span> <a href="godoc.288.html#Flags">Flags</a> = 0x4
    <span id="FlagPushPromisePadded">FlagPushPromisePadded</span>     <a href="godoc.288.html#Flags">Flags</a> = 0x8
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="Flags.Has">func (Flags) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=1591:1623#L57">Has</a>
					<a class="permalink" href="godoc.288.html#Flags.Has">&#xb6;</a>
					
					
				</h3>
				<pre>func (f <a href="godoc.288.html#Flags">Flags</a>) Has(v <a href="godoc.288.html#Flags">Flags</a>) <a href="godoc.4.html#bool">bool</a></pre>
				<p>
Has reports whether f contains all (0 or more) flags in v.
</p>

				
				
				
			
		
			
			
			<h2 id="Frame">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=6581:6786#L245">Frame</a>
				<a class="permalink" href="godoc.288.html#Frame">&#xb6;</a>
				
				
			</h2>
			<p>
A Frame is the base interface implemented by all frame types.
Callers will generally type-assert the specific frame type:
*HeadersFrame, *SettingsFrame, *WindowUpdateFrame, etc.
</p>
<p>
Frames are only valid until the next call to Framer.ReadFrame.
</p>

			<pre>type Frame interface {
    Header() <a href="godoc.288.html#FrameHeader">FrameHeader</a>
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="FrameHeader">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=3670:4434#L140">FrameHeader</a>
				<a class="permalink" href="godoc.288.html#FrameHeader">&#xb6;</a>
				
				
			</h2>
			<p>
A FrameHeader is the 9 byte header of all HTTP/2 frames.
</p>
<p>
See <a href="http://http2.github.io/http2-spec/#FrameHeader">http://http2.github.io/http2-spec/#FrameHeader</a>
</p>

			<pre>type FrameHeader struct {

<span id="FrameHeader.Type"></span>    <span class="comment">// Type is the 1 byte frame type. There are ten standard frame</span>
    <span class="comment">// types, but extension frame types may be written by WriteRawFrame</span>
    <span class="comment">// and will be returned by ReadFrame (as UnknownFrame).</span>
    Type <a href="godoc.288.html#FrameType">FrameType</a>

<span id="FrameHeader.Flags"></span>    <span class="comment">// Flags are the 1 byte of 8 potential bit flags per frame.</span>
    <span class="comment">// They are specific to the frame type.</span>
    Flags <a href="godoc.288.html#Flags">Flags</a>

<span id="FrameHeader.Length"></span>    <span class="comment">// Length is the length of the frame, not including the 9 byte header.</span>
    <span class="comment">// The maximum size is one byte less than 16MB (uint24), but only</span>
    <span class="comment">// frames up to 16KB are allowed without peer agreement.</span>
    Length <a href="godoc.4.html#uint32">uint32</a>

<span id="FrameHeader.StreamID"></span>    <span class="comment">// StreamID is which stream this frame is for. Certain frames</span>
    <span class="comment">// are not stream-specific, in which case this field is 0.</span>
    StreamID <a href="godoc.4.html#uint32">uint32</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="ReadFrameHeader">func <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=5769:5823#L220">ReadFrameHeader</a>
					<a class="permalink" href="godoc.288.html#ReadFrameHeader">&#xb6;</a>
					
					
				</h3>
				<pre>func ReadFrameHeader(r <a href="godoc.585.html">io</a>.<a href="godoc.585.html#Reader">Reader</a>) (<a href="godoc.288.html#FrameHeader">FrameHeader</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
ReadFrameHeader reads 9 bytes from r and returns a FrameHeader.
Most users should use Framer.ReadFrame instead.
</p>

				
				
			

			
				
				<h3 id="FrameHeader.Header">func (FrameHeader) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=4567:4608#L164">Header</a>
					<a class="permalink" href="godoc.288.html#FrameHeader.Header">&#xb6;</a>
					
					
				</h3>
				<pre>func (h <a href="godoc.288.html#FrameHeader">FrameHeader</a>) Header() <a href="godoc.288.html#FrameHeader">FrameHeader</a></pre>
				<p>
Header returns h. It exists so FrameHeaders can be embedded in other
specific frame types and implement the Frame interface.
</p>

				
				
				
			
				
				<h3 id="FrameHeader.String">func (FrameHeader) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=4623:4659#L166">String</a>
					<a class="permalink" href="godoc.288.html#FrameHeader.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (h <a href="godoc.288.html#FrameHeader">FrameHeader</a>) String() <a href="godoc.4.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="FrameType">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=523:543#L17">FrameType</a>
				<a class="permalink" href="godoc.288.html#FrameType">&#xb6;</a>
				
				
			</h2>
			<p>
A FrameType is a registered frame type as defined in
<a href="http://http2.github.io/http2-spec/#rfc.section.11.2">http://http2.github.io/http2-spec/#rfc.section.11.2</a>
</p>

			<pre>type FrameType <a href="godoc.4.html#uint8">uint8</a></pre>

			
				
				<pre>const (
    <span id="FrameData">FrameData</span>         <a href="godoc.288.html#FrameType">FrameType</a> = 0x0
    <span id="FrameHeaders">FrameHeaders</span>      <a href="godoc.288.html#FrameType">FrameType</a> = 0x1
    <span id="FramePriority">FramePriority</span>     <a href="godoc.288.html#FrameType">FrameType</a> = 0x2
    <span id="FrameRSTStream">FrameRSTStream</span>    <a href="godoc.288.html#FrameType">FrameType</a> = 0x3
    <span id="FrameSettings">FrameSettings</span>     <a href="godoc.288.html#FrameType">FrameType</a> = 0x4
    <span id="FramePushPromise">FramePushPromise</span>  <a href="godoc.288.html#FrameType">FrameType</a> = 0x5
    <span id="FramePing">FramePing</span>         <a href="godoc.288.html#FrameType">FrameType</a> = 0x6
    <span id="FrameGoAway">FrameGoAway</span>       <a href="godoc.288.html#FrameType">FrameType</a> = 0x7
    <span id="FrameWindowUpdate">FrameWindowUpdate</span> <a href="godoc.288.html#FrameType">FrameType</a> = 0x8
    <span id="FrameContinuation">FrameContinuation</span> <a href="godoc.288.html#FrameType">FrameType</a> = 0x9
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="FrameType.String">func (FrameType) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=1271:1305#L45">String</a>
					<a class="permalink" href="godoc.288.html#FrameType.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (t <a href="godoc.288.html#FrameType">FrameType</a>) String() <a href="godoc.4.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="FrameWriteRequest">type <a href="http://localhost:6161/src/golang.org/x/net/http2/writesched.go?s=1985:2536#L37">FrameWriteRequest</a>
				<a class="permalink" href="godoc.288.html#FrameWriteRequest">&#xb6;</a>
				
				
			</h2>
			<p>
FrameWriteRequest is a request to write a frame.
</p>

			<pre>type FrameWriteRequest struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="FrameWriteRequest.Consume">func (FrameWriteRequest) <a href="http://localhost:6161/src/golang.org/x/net/http2/writesched.go?s=4095:4183#L94">Consume</a>
					<a class="permalink" href="godoc.288.html#FrameWriteRequest.Consume">&#xb6;</a>
					
					
				</h3>
				<pre>func (wr <a href="godoc.288.html#FrameWriteRequest">FrameWriteRequest</a>) Consume(n <a href="godoc.4.html#int32">int32</a>) (<a href="godoc.288.html#FrameWriteRequest">FrameWriteRequest</a>, <a href="godoc.288.html#FrameWriteRequest">FrameWriteRequest</a>, <a href="godoc.4.html#int">int</a>)</pre>
				<p>
Consume consumes min(n, available) bytes from this frame, where available
is the number of flow control bytes available on the stream. Consume returns
0, 1, or 2 frames, where the integer return value gives the number of frames
returned.
</p>
<p>
If flow control prevents consuming any bytes, this returns (_, _, 0). If
the entire frame was consumed, this returns (wr, _, 1). Otherwise, this
returns (consumed, rest, 2), where &#39;consumed&#39; contains the consumed bytes and
&#39;rest&#39; contains the remaining bytes. The consumed bytes are deducted from the
underlying stream&#39;s flow control budget.
</p>

				
				
				
			
				
				<h3 id="FrameWriteRequest.DataSize">func (FrameWriteRequest) <a href="http://localhost:6161/src/golang.org/x/net/http2/writesched.go?s=3363:3405#L77">DataSize</a>
					<a class="permalink" href="godoc.288.html#FrameWriteRequest.DataSize">&#xb6;</a>
					
					
				</h3>
				<pre>func (wr <a href="godoc.288.html#FrameWriteRequest">FrameWriteRequest</a>) DataSize() <a href="godoc.4.html#int">int</a></pre>
				<p>
DataSize returns the number of flow control bytes that must be consumed
to write this entire frame. This is 0 for non-DATA frames.
</p>

				
				
				
			
				
				<h3 id="FrameWriteRequest.StreamID">func (FrameWriteRequest) <a href="http://localhost:6161/src/golang.org/x/net/http2/writesched.go?s=2672:2717#L55">StreamID</a>
					<a class="permalink" href="godoc.288.html#FrameWriteRequest.StreamID">&#xb6;</a>
					
					
				</h3>
				<pre>func (wr <a href="godoc.288.html#FrameWriteRequest">FrameWriteRequest</a>) StreamID() <a href="godoc.4.html#uint32">uint32</a></pre>
				<p>
StreamID returns the id of the stream this frame will be written to.
0 is used for non-stream frames such as PING and SETTINGS.
</p>

				
				
				
			
				
				<h3 id="FrameWriteRequest.String">func (FrameWriteRequest) <a href="http://localhost:6161/src/golang.org/x/net/http2/writesched.go?s=5519:5562#L149">String</a>
					<a class="permalink" href="godoc.288.html#FrameWriteRequest.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (wr <a href="godoc.288.html#FrameWriteRequest">FrameWriteRequest</a>) String() <a href="godoc.4.html#string">string</a></pre>
				<p>
String is for debugging only.
</p>

				
				
				
			
		
			
			
			<h2 id="Framer">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=6825:9084#L255">Framer</a>
				<a class="permalink" href="godoc.288.html#Framer">&#xb6;</a>
				
				
			</h2>
			<p>
A Framer reads and writes Frames.
</p>

			<pre>type Framer struct {

<span id="Framer.AllowIllegalWrites"></span>    <span class="comment">// AllowIllegalWrites permits the Framer&#39;s Write methods to</span>
    <span class="comment">// write frames that do not conform to the HTTP/2 spec. This</span>
    <span class="comment">// permits using the Framer to test other HTTP/2</span>
    <span class="comment">// implementations&#39; conformance to the spec.</span>
    <span class="comment">// If false, the Write methods will prefer to return an error</span>
    <span class="comment">// rather than comply.</span>
    AllowIllegalWrites <a href="godoc.4.html#bool">bool</a>

<span id="Framer.AllowIllegalReads"></span>    <span class="comment">// AllowIllegalReads permits the Framer&#39;s ReadFrame method</span>
    <span class="comment">// to return non-compliant frames or frame orders.</span>
    <span class="comment">// This is for testing and permits using the Framer to test</span>
    <span class="comment">// other HTTP/2 implementations&#39; conformance to the spec.</span>
    <span class="comment">// It is not compatible with ReadMetaHeaders.</span>
    AllowIllegalReads <a href="godoc.4.html#bool">bool</a>

<span id="Framer.ReadMetaHeaders"></span>    <span class="comment">// ReadMetaHeaders if non-nil causes ReadFrame to merge</span>
    <span class="comment">// HEADERS and CONTINUATION frames together and return</span>
    <span class="comment">// MetaHeadersFrame instead.</span>
    ReadMetaHeaders *<a href="godoc.291.html">hpack</a>.<a href="godoc.291.html#Decoder">Decoder</a>

<span id="Framer.MaxHeaderListSize"></span>    <span class="comment">// MaxHeaderListSize is the http2 MAX_HEADER_LIST_SIZE.</span>
    <span class="comment">// It&#39;s used only if ReadMetaHeaders is set; 0 means a sane default</span>
    <span class="comment">// (currently 16MB)</span>
    <span class="comment">// If the limit is hit, MetaHeadersFrame.Truncated is set true.</span>
    MaxHeaderListSize <a href="godoc.4.html#uint32">uint32</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewFramer">func <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=11575:11623#L415">NewFramer</a>
					<a class="permalink" href="godoc.288.html#NewFramer">&#xb6;</a>
					
					
				</h3>
				<pre>func NewFramer(w <a href="godoc.585.html">io</a>.<a href="godoc.585.html#Writer">Writer</a>, r <a href="godoc.585.html">io</a>.<a href="godoc.585.html#Reader">Reader</a>) *<a href="godoc.288.html#Framer">Framer</a></pre>
				<p>
NewFramer returns a Framer that writes frames to w and reads them from r.
</p>

				
				
			

			
				
				<h3 id="Framer.ErrorDetail">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=12821:12858#L453">ErrorDetail</a>
					<a class="permalink" href="godoc.288.html#Framer.ErrorDetail">&#xb6;</a>
					
					
				</h3>
				<pre>func (fr *<a href="godoc.288.html#Framer">Framer</a>) ErrorDetail() <a href="godoc.4.html#error">error</a></pre>
				<p>
ErrorDetail returns a more detailed error of the last error
returned by Framer.ReadFrame. For instance, if ReadFrame
returns a StreamError with code PROTOCOL_ERROR, ErrorDetail
will say exactly what was invalid. ErrorDetail is not guaranteed
to return a non-nil value and like the rest of the http2 package,
its return value is not protected by an API compatibility promise.
ErrorDetail is reset after the next call to ReadFrame.
</p>

				
				
				
			
				
				<h3 id="Framer.ReadFrame">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=13667:13711#L477">ReadFrame</a>
					<a class="permalink" href="godoc.288.html#Framer.ReadFrame">&#xb6;</a>
					
					
				</h3>
				<pre>func (fr *<a href="godoc.288.html#Framer">Framer</a>) ReadFrame() (<a href="godoc.288.html#Frame">Frame</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
ReadFrame reads a single frame. The returned Frame is only valid
until the next call to ReadFrame.
</p>
<p>
If the frame is larger than previously set with SetMaxReadFrameSize, the
returned error is ErrFrameTooLarge. Other errors may be of type
ConnectionError, StreamError, or anything else from the underlying
reader.
</p>

				
				
				
			
				
				<h3 id="Framer.SetMaxReadFrameSize">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=12252:12299#L439">SetMaxReadFrameSize</a>
					<a class="permalink" href="godoc.288.html#Framer.SetMaxReadFrameSize">&#xb6;</a>
					
					
				</h3>
				<pre>func (fr *<a href="godoc.288.html#Framer">Framer</a>) SetMaxReadFrameSize(v <a href="godoc.4.html#uint32">uint32</a>)</pre>
				<p>
SetMaxReadFrameSize sets the maximum size of a frame
that will be read by a subsequent call to ReadFrame.
It is the caller&#39;s responsibility to advertise this
limit with a SETTINGS frame.
</p>

				
				
				
			
				
				<h3 id="Framer.SetReuseFrames">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=11223:11257#L396">SetReuseFrames</a>
					<a class="permalink" href="godoc.288.html#Framer.SetReuseFrames">&#xb6;</a>
					
					
				</h3>
				<pre>func (fr *<a href="godoc.288.html#Framer">Framer</a>) SetReuseFrames()</pre>
				<p>
SetReuseFrames allows the Framer to reuse Frames.
If called on a Framer, Frames returned by calls to ReadFrame are only
valid until the next call to ReadFrame.
</p>

				
				
				
			
				
				<h3 id="Framer.WriteContinuation">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=35329:35431#L1215">WriteContinuation</a>
					<a class="permalink" href="godoc.288.html#Framer.WriteContinuation">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#Framer">Framer</a>) WriteContinuation(streamID <a href="godoc.4.html#uint32">uint32</a>, endHeaders <a href="godoc.4.html#bool">bool</a>, headerBlockFragment []<a href="godoc.4.html#byte">byte</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
WriteContinuation writes a CONTINUATION frame.
</p>
<p>
It will perform exactly one Write to the underlying Writer.
It is the caller&#39;s responsibility to not call other Write methods concurrently.
</p>

				
				
				
			
				
				<h3 id="Framer.WriteData">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=18276:18354#L632">WriteData</a>
					<a class="permalink" href="godoc.288.html#Framer.WriteData">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#Framer">Framer</a>) WriteData(streamID <a href="godoc.4.html#uint32">uint32</a>, endStream <a href="godoc.4.html#bool">bool</a>, data []<a href="godoc.4.html#byte">byte</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
WriteData writes a DATA frame.
</p>
<p>
It will perform exactly one Write to the underlying Writer.
It is the caller&#39;s responsibility not to violate the maximum frame size
and to not call other Write methods concurrently.
</p>

				
				
				
			
				
				<h3 id="Framer.WriteDataPadded">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=18846:18935#L645">WriteDataPadded</a>
					<a class="permalink" href="godoc.288.html#Framer.WriteDataPadded">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#Framer">Framer</a>) WriteDataPadded(streamID <a href="godoc.4.html#uint32">uint32</a>, endStream <a href="godoc.4.html#bool">bool</a>, data, pad []<a href="godoc.4.html#byte">byte</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
WriteDataPadded writes a DATA frame with optional padding.
</p>
<p>
If pad is nil, the padding bit is not sent.
The length of pad must not exceed 255 bytes.
The bytes of pad must all be zero, unless f.AllowIllegalWrites is set.
</p>
<p>
It will perform exactly one Write to the underlying Writer.
It is the caller&#39;s responsibility not to violate the maximum frame size
and to not call other Write methods concurrently.
</p>

				
				
				
			
				
				<h3 id="Framer.WriteGoAway">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=25368:25454#L880">WriteGoAway</a>
					<a class="permalink" href="godoc.288.html#Framer.WriteGoAway">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#Framer">Framer</a>) WriteGoAway(maxStreamID <a href="godoc.4.html#uint32">uint32</a>, code <a href="godoc.288.html#ErrCode">ErrCode</a>, debugData []<a href="godoc.4.html#byte">byte</a>) <a href="godoc.4.html#error">error</a></pre>
				
				
				
				
			
				
				<h3 id="Framer.WriteHeaders">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=30734:30790#L1053">WriteHeaders</a>
					<a class="permalink" href="godoc.288.html#Framer.WriteHeaders">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#Framer">Framer</a>) WriteHeaders(p <a href="godoc.288.html#HeadersFrameParam">HeadersFrameParam</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
WriteHeaders writes a single HEADERS frame.
</p>
<p>
This is a low-level header writing method. Encoding headers and
splitting them into any necessary CONTINUATION frames is handled
elsewhere.
</p>
<p>
It will perform exactly one Write to the underlying Writer.
It is the caller&#39;s responsibility to not call other Write methods concurrently.
</p>

				
				
				
			
				
				<h3 id="Framer.WritePing">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=24250:24306#L837">WritePing</a>
					<a class="permalink" href="godoc.288.html#Framer.WritePing">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#Framer">Framer</a>) WritePing(ack <a href="godoc.4.html#bool">bool</a>, data [8]<a href="godoc.4.html#byte">byte</a>) <a href="godoc.4.html#error">error</a></pre>
				
				
				
				
			
				
				<h3 id="Framer.WritePriority">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=33162:33232#L1141">WritePriority</a>
					<a class="permalink" href="godoc.288.html#Framer.WritePriority">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#Framer">Framer</a>) WritePriority(streamID <a href="godoc.4.html#uint32">uint32</a>, p <a href="godoc.288.html#PriorityParam">PriorityParam</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
WritePriority writes a PRIORITY frame.
</p>
<p>
It will perform exactly one Write to the underlying Writer.
It is the caller&#39;s responsibility to not call other Write methods concurrently.
</p>

				
				
				
			
				
				<h3 id="Framer.WritePushPromise">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=38211:38270#L1310">WritePushPromise</a>
					<a class="permalink" href="godoc.288.html#Framer.WritePushPromise">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#Framer">Framer</a>) WritePushPromise(p <a href="godoc.288.html#PushPromiseParam">PushPromiseParam</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
WritePushPromise writes a single PushPromise Frame.
</p>
<p>
As with Header Frames, This is the low level call for writing
individual frames. Continuation frames are handled elsewhere.
</p>
<p>
It will perform exactly one Write to the underlying Writer.
It is the caller&#39;s responsibility to not call other Write methods concurrently.
</p>

				
				
				
			
				
				<h3 id="Framer.WriteRSTStream">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=34224:34292#L1179">WriteRSTStream</a>
					<a class="permalink" href="godoc.288.html#Framer.WriteRSTStream">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#Framer">Framer</a>) WriteRSTStream(streamID <a href="godoc.4.html#uint32">uint32</a>, code <a href="godoc.288.html#ErrCode">ErrCode</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
WriteRSTStream writes a RST_STREAM frame.
</p>
<p>
It will perform exactly one Write to the underlying Writer.
It is the caller&#39;s responsibility to not call other Write methods concurrently.
</p>

				
				
				
			
				
				<h3 id="Framer.WriteRawFrame">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=38934:39029#L1336">WriteRawFrame</a>
					<a class="permalink" href="godoc.288.html#Framer.WriteRawFrame">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#Framer">Framer</a>) WriteRawFrame(t <a href="godoc.288.html#FrameType">FrameType</a>, flags <a href="godoc.288.html#Flags">Flags</a>, streamID <a href="godoc.4.html#uint32">uint32</a>, payload []<a href="godoc.4.html#byte">byte</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
WriteRawFrame writes a raw frame. This can be used to write
extension frames unknown to this package.
</p>

				
				
				
			
				
				<h3 id="Framer.WriteSettings">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=23050:23107#L796">WriteSettings</a>
					<a class="permalink" href="godoc.288.html#Framer.WriteSettings">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#Framer">Framer</a>) WriteSettings(settings ...<a href="godoc.288.html#Setting">Setting</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
WriteSettings writes a SETTINGS frame with zero or more settings
specified and the ACK bit not set.
</p>
<p>
It will perform exactly one Write to the underlying Writer.
It is the caller&#39;s responsibility to not call other Write methods concurrently.
</p>

				
				
				
			
				
				<h3 id="Framer.WriteSettingsAck">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=23477:23518#L809">WriteSettingsAck</a>
					<a class="permalink" href="godoc.288.html#Framer.WriteSettingsAck">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#Framer">Framer</a>) WriteSettingsAck() <a href="godoc.4.html#error">error</a></pre>
				<p>
WriteSettingsAck writes an empty SETTINGS frame with the ACK bit set.
</p>
<p>
It will perform exactly one Write to the underlying Writer.
It is the caller&#39;s responsibility to not call other Write methods concurrently.
</p>

				
				
				
			
				
				<h3 id="Framer.WriteWindowUpdate">func (*Framer) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=27435:27498#L943">WriteWindowUpdate</a>
					<a class="permalink" href="godoc.288.html#Framer.WriteWindowUpdate">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#Framer">Framer</a>) WriteWindowUpdate(streamID, incr <a href="godoc.4.html#uint32">uint32</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
WriteWindowUpdate writes a WINDOW_UPDATE frame.
The increment value must be between 1 and 2,147,483,647, inclusive.
If the Stream ID is zero, the window update applies to the
connection as a whole.
</p>

				
				
				
			
		
			
			
			<h2 id="GoAwayError">type <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=49943:50034#L1674">GoAwayError</a>
				<a class="permalink" href="godoc.288.html#GoAwayError">&#xb6;</a>
				
				
			</h2>
			<p>
GoAwayError is returned by the Transport when the server closes the
TCP connection after sending a GOAWAY frame.
</p>

			<pre>type GoAwayError struct {
<span id="GoAwayError.LastStreamID"></span>    LastStreamID <a href="godoc.4.html#uint32">uint32</a>
<span id="GoAwayError.ErrCode"></span>    ErrCode      <a href="godoc.288.html#ErrCode">ErrCode</a>
<span id="GoAwayError.DebugData"></span>    DebugData    <a href="godoc.4.html#string">string</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="GoAwayError.Error">func (GoAwayError) <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=50036:50071#L1680">Error</a>
					<a class="permalink" href="godoc.288.html#GoAwayError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e <a href="godoc.288.html#GoAwayError">GoAwayError</a>) Error() <a href="godoc.4.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="GoAwayFrame">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=24587:24691#L849">GoAwayFrame</a>
				<a class="permalink" href="godoc.288.html#GoAwayFrame">&#xb6;</a>
				
				
			</h2>
			<p>
A GoAwayFrame informs the remote peer to stop creating streams on this connection.
See <a href="http://http2.github.io/http2-spec/#rfc.section.6.8">http://http2.github.io/http2-spec/#rfc.section.6.8</a>
</p>

			<pre>type GoAwayFrame struct {
    <a href="godoc.288.html#FrameHeader">FrameHeader</a>
<span id="GoAwayFrame.LastStreamID"></span>    LastStreamID <a href="godoc.4.html#uint32">uint32</a>
<span id="GoAwayFrame.ErrCode"></span>    ErrCode      <a href="godoc.288.html#ErrCode">ErrCode</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="GoAwayFrame.DebugData">func (*GoAwayFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=24869:24909#L860">DebugData</a>
					<a class="permalink" href="godoc.288.html#GoAwayFrame.DebugData">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#GoAwayFrame">GoAwayFrame</a>) DebugData() []<a href="godoc.4.html#byte">byte</a></pre>
				<p>
DebugData returns any debug data in the GOAWAY frame. Its contents
are not defined.
The caller must not retain the returned memory past the next
call to ReadFrame.
</p>

				
				
				
			
		
			
			
			<h2 id="HeadersFrame">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=27914:28086#L955">HeadersFrame</a>
				<a class="permalink" href="godoc.288.html#HeadersFrame">&#xb6;</a>
				
				
			</h2>
			<p>
A HeadersFrame is used to open a stream and additionally carries a
header block fragment.
</p>

			<pre>type HeadersFrame struct {
    <a href="godoc.288.html#FrameHeader">FrameHeader</a>

<span id="HeadersFrame.Priority"></span>    <span class="comment">// Priority is set if FlagHeadersPriority is set in the FrameHeader.</span>
    Priority <a href="godoc.288.html#PriorityParam">PriorityParam</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="HeadersFrame.HasPriority">func (*HeadersFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=28389:28430#L977">HasPriority</a>
					<a class="permalink" href="godoc.288.html#HeadersFrame.HasPriority">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#HeadersFrame">HeadersFrame</a>) HasPriority() <a href="godoc.4.html#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="HeadersFrame.HeaderBlockFragment">func (*HeadersFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=28088:28139#L964">HeaderBlockFragment</a>
					<a class="permalink" href="godoc.288.html#HeadersFrame.HeaderBlockFragment">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#HeadersFrame">HeadersFrame</a>) HeaderBlockFragment() []<a href="godoc.4.html#byte">byte</a></pre>
				
				
				
				
			
				
				<h3 id="HeadersFrame.HeadersEnded">func (*HeadersFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=28185:28227#L969">HeadersEnded</a>
					<a class="permalink" href="godoc.288.html#HeadersFrame.HeadersEnded">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#HeadersFrame">HeadersFrame</a>) HeadersEnded() <a href="godoc.4.html#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="HeadersFrame.StreamEnded">func (*HeadersFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=28288:28329#L973">StreamEnded</a>
					<a class="permalink" href="godoc.288.html#HeadersFrame.StreamEnded">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#HeadersFrame">HeadersFrame</a>) StreamEnded() <a href="godoc.4.html#bool">bool</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="HeadersFrameParam">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=29630:30384#L1019">HeadersFrameParam</a>
				<a class="permalink" href="godoc.288.html#HeadersFrameParam">&#xb6;</a>
				
				
			</h2>
			<p>
HeadersFrameParam are the parameters for writing a HEADERS frame.
</p>

			<pre>type HeadersFrameParam struct {
<span id="HeadersFrameParam.StreamID"></span>    <span class="comment">// StreamID is the required Stream ID to initiate.</span>
    StreamID <a href="godoc.4.html#uint32">uint32</a>
<span id="HeadersFrameParam.BlockFragment"></span>    <span class="comment">// BlockFragment is part (or all) of a Header Block.</span>
    BlockFragment []<a href="godoc.4.html#byte">byte</a>

<span id="HeadersFrameParam.EndStream"></span>    <span class="comment">// EndStream indicates that the header block is the last that</span>
    <span class="comment">// the endpoint will send for the identified stream. Setting</span>
    <span class="comment">// this flag causes the stream to enter one of &#34;half closed&#34;</span>
    <span class="comment">// states.</span>
    EndStream <a href="godoc.4.html#bool">bool</a>

<span id="HeadersFrameParam.EndHeaders"></span>    <span class="comment">// EndHeaders indicates that this frame contains an entire</span>
    <span class="comment">// header block and is not followed by any</span>
    <span class="comment">// CONTINUATION frames.</span>
    EndHeaders <a href="godoc.4.html#bool">bool</a>

<span id="HeadersFrameParam.PadLength"></span>    <span class="comment">// PadLength is the optional number of bytes of zeros to add</span>
    <span class="comment">// to this frame.</span>
    PadLength <a href="godoc.4.html#uint8">uint8</a>

<span id="HeadersFrameParam.Priority"></span>    <span class="comment">// Priority, if non-zero, includes stream priority information</span>
    <span class="comment">// in the HEADER frame.</span>
    Priority <a href="godoc.288.html#PriorityParam">PriorityParam</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="MetaHeadersFrame">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=39924:40643#L1375">MetaHeadersFrame</a>
				<a class="permalink" href="godoc.288.html#MetaHeadersFrame">&#xb6;</a>
				
				
			</h2>
			<p>
A MetaHeadersFrame is the representation of one HEADERS frame and
zero or more contiguous CONTINUATION frames and the decoding of
their HPACK-encoded contents.
</p>
<p>
This type of frame does not appear on the wire and is only returned
by the Framer when Framer.ReadMetaHeaders is set.
</p>

			<pre>type MetaHeadersFrame struct {
    *<a href="godoc.288.html#HeadersFrame">HeadersFrame</a>

<span id="MetaHeadersFrame.Fields"></span>    <span class="comment">// Fields are the fields contained in the HEADERS and</span>
    <span class="comment">// CONTINUATION frames. The underlying slice is owned by the</span>
    <span class="comment">// Framer and must not be retained after the next call to</span>
    <span class="comment">// ReadFrame.</span>
    <span class="comment">//</span>
    <span class="comment">// Fields are guaranteed to be in the correct http2 order and</span>
    <span class="comment">// not have unknown pseudo header fields or invalid header</span>
    <span class="comment">// field names or values. Required pseudo header fields may be</span>
    <span class="comment">// missing, however. Use the MetaHeadersFrame.Pseudo accessor</span>
    <span class="comment">// method access pseudo headers.</span>
    Fields []<a href="godoc.291.html">hpack</a>.<a href="godoc.291.html#HeaderField">HeaderField</a>

<span id="MetaHeadersFrame.Truncated"></span>    <span class="comment">// Truncated is whether the max header list size limit was hit</span>
    <span class="comment">// and Fields is incomplete. The hpack decoder state is still</span>
    <span class="comment">// valid, however.</span>
    Truncated <a href="godoc.4.html#bool">bool</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MetaHeadersFrame.PseudoFields">func (*MetaHeadersFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=41365:41427#L1423">PseudoFields</a>
					<a class="permalink" href="godoc.288.html#MetaHeadersFrame.PseudoFields">&#xb6;</a>
					
					
				</h3>
				<pre>func (mh *<a href="godoc.288.html#MetaHeadersFrame">MetaHeadersFrame</a>) PseudoFields() []<a href="godoc.291.html">hpack</a>.<a href="godoc.291.html#HeaderField">HeaderField</a></pre>
				<p>
PseudoFields returns the pseudo header fields of mh.
The caller does not own the returned slice.
</p>

				
				
				
			
				
				<h3 id="MetaHeadersFrame.PseudoValue">func (*MetaHeadersFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=40774:40835#L1398">PseudoValue</a>
					<a class="permalink" href="godoc.288.html#MetaHeadersFrame.PseudoValue">&#xb6;</a>
					
					
				</h3>
				<pre>func (mh *<a href="godoc.288.html#MetaHeadersFrame">MetaHeadersFrame</a>) PseudoValue(pseudo <a href="godoc.4.html#string">string</a>) <a href="godoc.4.html#string">string</a></pre>
				<p>
PseudoValue returns the given pseudo header field&#39;s value.
The provided pseudo field should not contain the leading colon.
</p>

				
				
				
			
				
				<h3 id="MetaHeadersFrame.RegularFields">func (*MetaHeadersFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=41096:41159#L1412">RegularFields</a>
					<a class="permalink" href="godoc.288.html#MetaHeadersFrame.RegularFields">&#xb6;</a>
					
					
				</h3>
				<pre>func (mh *<a href="godoc.288.html#MetaHeadersFrame">MetaHeadersFrame</a>) RegularFields() []<a href="godoc.291.html">hpack</a>.<a href="godoc.291.html#HeaderField">HeaderField</a></pre>
				<p>
RegularFields returns the regular (non-pseudo) header fields of mh.
The caller does not own the returned slice.
</p>

				
				
				
			
		
			
			
			<h2 id="OpenStreamOptions">type <a href="http://localhost:6161/src/golang.org/x/net/http2/writesched.go?s=1739:1931#L30">OpenStreamOptions</a>
				<a class="permalink" href="godoc.288.html#OpenStreamOptions">&#xb6;</a>
				
				
			</h2>
			<p>
OpenStreamOptions specifies extra options for WriteScheduler.OpenStream.
</p>

			<pre>type OpenStreamOptions struct {
<span id="OpenStreamOptions.PusherID"></span>    <span class="comment">// PusherID is zero if the stream was initiated by the client. Otherwise,</span>
    <span class="comment">// PusherID names the stream that pushed the newly opened stream.</span>
    PusherID <a href="godoc.4.html#uint32">uint32</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="PingFrame">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=23816:23868#L818">PingFrame</a>
				<a class="permalink" href="godoc.288.html#PingFrame">&#xb6;</a>
				
				
			</h2>
			<p>
A PingFrame is a mechanism for measuring a minimal round trip time
from the sender, as well as determining whether an idle connection
is still functional.
See <a href="http://http2.github.io/http2-spec/#rfc.section.6.7">http://http2.github.io/http2-spec/#rfc.section.6.7</a>
</p>

			<pre>type PingFrame struct {
    <a href="godoc.288.html#FrameHeader">FrameHeader</a>
<span id="PingFrame.Data"></span>    Data [8]<a href="godoc.4.html#byte">byte</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="PingFrame.IsAck">func (*PingFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=23870:23902#L823">IsAck</a>
					<a class="permalink" href="godoc.288.html#PingFrame.IsAck">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#PingFrame">PingFrame</a>) IsAck() <a href="godoc.4.html#bool">bool</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="PriorityFrame">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=31708:31765#L1092">PriorityFrame</a>
				<a class="permalink" href="godoc.288.html#PriorityFrame">&#xb6;</a>
				
				
			</h2>
			<p>
A PriorityFrame specifies the sender-advised priority of a stream.
See <a href="http://http2.github.io/http2-spec/#rfc.section.6.3">http://http2.github.io/http2-spec/#rfc.section.6.3</a>
</p>

			<pre>type PriorityFrame struct {
    <a href="godoc.288.html#FrameHeader">FrameHeader</a>
    <a href="godoc.288.html#PriorityParam">PriorityParam</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="PriorityParam">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=31825:32283#L1098">PriorityParam</a>
				<a class="permalink" href="godoc.288.html#PriorityParam">&#xb6;</a>
				
				
			</h2>
			<p>
PriorityParam are the stream prioritzation parameters.
</p>

			<pre>type PriorityParam struct {
<span id="PriorityParam.StreamDep"></span>    <span class="comment">// StreamDep is a 31-bit stream identifier for the</span>
    <span class="comment">// stream that this stream depends on. Zero means no</span>
    <span class="comment">// dependency.</span>
    StreamDep <a href="godoc.4.html#uint32">uint32</a>

<span id="PriorityParam.Exclusive"></span>    <span class="comment">// Exclusive is whether the dependency is exclusive.</span>
    Exclusive <a href="godoc.4.html#bool">bool</a>

<span id="PriorityParam.Weight"></span>    <span class="comment">// Weight is the stream&#39;s zero-indexed weight. It should be</span>
    <span class="comment">// set together with StreamDep, or neither should be set. Per</span>
    <span class="comment">// the spec, &#34;Add one to the value to obtain a weight between</span>
    <span class="comment">// 1 and 256.&#34;</span>
    Weight <a href="godoc.4.html#uint8">uint8</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="PriorityParam.IsZero">func (PriorityParam) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=32285:32321#L1114">IsZero</a>
					<a class="permalink" href="godoc.288.html#PriorityParam.IsZero">&#xb6;</a>
					
					
				</h3>
				<pre>func (p <a href="godoc.288.html#PriorityParam">PriorityParam</a>) IsZero() <a href="godoc.4.html#bool">bool</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="PriorityWriteSchedulerConfig">type <a href="http://localhost:6161/src/golang.org/x/net/http2/writesched_priority.go?s=382:2343#L7">PriorityWriteSchedulerConfig</a>
				<a class="permalink" href="godoc.288.html#PriorityWriteSchedulerConfig">&#xb6;</a>
				
				
			</h2>
			<p>
PriorityWriteSchedulerConfig configures a priorityWriteScheduler.
</p>

			<pre>type PriorityWriteSchedulerConfig struct {
<span id="PriorityWriteSchedulerConfig.MaxClosedNodesInTree"></span>    <span class="comment">// MaxClosedNodesInTree controls the maximum number of closed streams to</span>
    <span class="comment">// retain in the priority tree. Setting this to zero saves a small amount</span>
    <span class="comment">// of memory at the cost of performance.</span>
    <span class="comment">//</span>
    <span class="comment">// See RFC 7540, Section 5.3.4:</span>
    <span class="comment">//   &#34;It is possible for a stream to become closed while prioritization</span>
    <span class="comment">//   information ... is in transit. ... This potentially creates suboptimal</span>
    <span class="comment">//   prioritization, since the stream could be given a priority that is</span>
    <span class="comment">//   different from what is intended. To avoid these problems, an endpoint</span>
    <span class="comment">//   SHOULD retain stream prioritization state for a period after streams</span>
    <span class="comment">//   become closed. The longer state is retained, the lower the chance that</span>
    <span class="comment">//   streams are assigned incorrect or default priority values.&#34;</span>
    MaxClosedNodesInTree <a href="godoc.4.html#int">int</a>

<span id="PriorityWriteSchedulerConfig.MaxIdleNodesInTree"></span>    <span class="comment">// MaxIdleNodesInTree controls the maximum number of idle streams to</span>
    <span class="comment">// retain in the priority tree. Setting this to zero saves a small amount</span>
    <span class="comment">// of memory at the cost of performance.</span>
    <span class="comment">//</span>
    <span class="comment">// See RFC 7540, Section 5.3.4:</span>
    <span class="comment">//   Similarly, streams that are in the &#34;idle&#34; state can be assigned</span>
    <span class="comment">//   priority or become a parent of other streams. This allows for the</span>
    <span class="comment">//   creation of a grouping node in the dependency tree, which enables</span>
    <span class="comment">//   more flexible expressions of priority. Idle streams begin with a</span>
    <span class="comment">//   default priority (Section 5.3.5).</span>
    MaxIdleNodesInTree <a href="godoc.4.html#int">int</a>

<span id="PriorityWriteSchedulerConfig.ThrottleOutOfOrderWrites"></span>    <span class="comment">// ThrottleOutOfOrderWrites enables write throttling to help ensure that</span>
    <span class="comment">// data is delivered in priority order. This works around a race where</span>
    <span class="comment">// stream B depends on stream A and both streams are about to call Write</span>
    <span class="comment">// to queue DATA frames. If B wins the race, a naive scheduler would eagerly</span>
    <span class="comment">// write as much data from B as possible, but this is suboptimal because A</span>
    <span class="comment">// is a higher-priority stream. With throttling enabled, we write a small</span>
    <span class="comment">// amount of data from B to minimize the amount of bandwidth that B can</span>
    <span class="comment">// steal from A.</span>
    ThrottleOutOfOrderWrites <a href="godoc.4.html#bool">bool</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="PushPromiseFrame">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=35829:35931#L1230">PushPromiseFrame</a>
				<a class="permalink" href="godoc.288.html#PushPromiseFrame">&#xb6;</a>
				
				
			</h2>
			<p>
A PushPromiseFrame is used to initiate a server stream.
See <a href="http://http2.github.io/http2-spec/#rfc.section.6.6">http://http2.github.io/http2-spec/#rfc.section.6.6</a>
</p>

			<pre>type PushPromiseFrame struct {
    <a href="godoc.288.html#FrameHeader">FrameHeader</a>
<span id="PushPromiseFrame.PromiseID"></span>    PromiseID <a href="godoc.4.html#uint32">uint32</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="PushPromiseFrame.HeaderBlockFragment">func (*PushPromiseFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=35933:35988#L1236">HeaderBlockFragment</a>
					<a class="permalink" href="godoc.288.html#PushPromiseFrame.HeaderBlockFragment">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#PushPromiseFrame">PushPromiseFrame</a>) HeaderBlockFragment() []<a href="godoc.4.html#byte">byte</a></pre>
				
				
				
				
			
				
				<h3 id="PushPromiseFrame.HeadersEnded">func (*PushPromiseFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=36034:36080#L1241">HeadersEnded</a>
					<a class="permalink" href="godoc.288.html#PushPromiseFrame.HeadersEnded">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#PushPromiseFrame">PushPromiseFrame</a>) HeadersEnded() <a href="godoc.4.html#bool">bool</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="PushPromiseParam">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=37360:37872#L1282">PushPromiseParam</a>
				<a class="permalink" href="godoc.288.html#PushPromiseParam">&#xb6;</a>
				
				
			</h2>
			<p>
PushPromiseParam are the parameters for writing a PUSH_PROMISE frame.
</p>

			<pre>type PushPromiseParam struct {
<span id="PushPromiseParam.StreamID"></span>    <span class="comment">// StreamID is the required Stream ID to initiate.</span>
    StreamID <a href="godoc.4.html#uint32">uint32</a>

<span id="PushPromiseParam.PromiseID"></span>    <span class="comment">// PromiseID is the required Stream ID which this</span>
    <span class="comment">// Push Promises</span>
    PromiseID <a href="godoc.4.html#uint32">uint32</a>

<span id="PushPromiseParam.BlockFragment"></span>    <span class="comment">// BlockFragment is part (or all) of a Header Block.</span>
    BlockFragment []<a href="godoc.4.html#byte">byte</a>

<span id="PushPromiseParam.EndHeaders"></span>    <span class="comment">// EndHeaders indicates that this frame contains an entire</span>
    <span class="comment">// header block and is not followed by any</span>
    <span class="comment">// CONTINUATION frames.</span>
    EndHeaders <a href="godoc.4.html#bool">bool</a>

<span id="PushPromiseParam.PadLength"></span>    <span class="comment">// PadLength is the optional number of bytes of zeros to add</span>
    <span class="comment">// to this frame.</span>
    PadLength <a href="godoc.4.html#uint8">uint8</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="RSTStreamFrame">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=33666:33726#L1160">RSTStreamFrame</a>
				<a class="permalink" href="godoc.288.html#RSTStreamFrame">&#xb6;</a>
				
				
			</h2>
			<p>
A RSTStreamFrame allows for abnormal termination of a stream.
See <a href="http://http2.github.io/http2-spec/#rfc.section.6.4">http://http2.github.io/http2-spec/#rfc.section.6.4</a>
</p>

			<pre>type RSTStreamFrame struct {
    <a href="godoc.288.html#FrameHeader">FrameHeader</a>
<span id="RSTStreamFrame.ErrCode"></span>    ErrCode <a href="godoc.288.html#ErrCode">ErrCode</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="RoundTripOpt">type <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=12925:13161#L390">RoundTripOpt</a>
				<a class="permalink" href="godoc.288.html#RoundTripOpt">&#xb6;</a>
				
				
			</h2>
			<p>
RoundTripOpt are options for the Transport.RoundTripOpt method.
</p>

			<pre>type RoundTripOpt struct {
<span id="RoundTripOpt.OnlyCachedConn"></span>    <span class="comment">// OnlyCachedConn controls whether RoundTripOpt may</span>
    <span class="comment">// create a new TCP connection. If set true and</span>
    <span class="comment">// no cached connection is available, RoundTripOpt</span>
    <span class="comment">// will return ErrNoCachedConn.</span>
    OnlyCachedConn <a href="godoc.4.html#bool">bool</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ServeConnOpts">type <a href="http://localhost:6161/src/golang.org/x/net/http2/server.go?s=9916:10382#L299">ServeConnOpts</a>
				<a class="permalink" href="godoc.288.html#ServeConnOpts">&#xb6;</a>
				
				
			</h2>
			<p>
ServeConnOpts are options for the Server.ServeConn method.
</p>

			<pre>type ServeConnOpts struct {
<span id="ServeConnOpts.Context"></span>    <span class="comment">// Context is the base context to use.</span>
    <span class="comment">// If nil, context.Background is used.</span>
    Context <a href="godoc.137.html">context</a>.<a href="godoc.137.html#Context">Context</a>

<span id="ServeConnOpts.BaseConfig"></span>    <span class="comment">// BaseConfig optionally sets the base configuration</span>
    <span class="comment">// for values. If nil, defaults are used.</span>
    BaseConfig *<a href="godoc.16.html">http</a>.<a href="godoc.16.html#Server">Server</a>

<span id="ServeConnOpts.Handler"></span>    <span class="comment">// Handler specifies which handler to use for processing</span>
    <span class="comment">// requests. If nil, BaseConfig.Handler is used. If BaseConfig</span>
    <span class="comment">// or BaseConfig.Handler is nil, http.DefaultServeMux is used.</span>
    Handler <a href="godoc.16.html">http</a>.<a href="godoc.16.html#Handler">Handler</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Server">type <a href="http://localhost:6161/src/golang.org/x/net/http2/server.go?s=2668:4819#L76">Server</a>
				<a class="permalink" href="godoc.288.html#Server">&#xb6;</a>
				
				
			</h2>
			<p>
Server is an HTTP/2 server.
</p>

			<pre>type Server struct {
<span id="Server.MaxHandlers"></span>    <span class="comment">// MaxHandlers limits the number of http.Handler ServeHTTP goroutines</span>
    <span class="comment">// which may run at a time over all connections.</span>
    <span class="comment">// Negative or zero no limit.</span>
    <span class="comment">// TODO: implement</span>
    MaxHandlers <a href="godoc.4.html#int">int</a>

<span id="Server.MaxConcurrentStreams"></span>    <span class="comment">// MaxConcurrentStreams optionally specifies the number of</span>
    <span class="comment">// concurrent streams that each client may have open at a</span>
    <span class="comment">// time. This is unrelated to the number of http.Handler goroutines</span>
    <span class="comment">// which may be active globally, which is MaxHandlers.</span>
    <span class="comment">// If zero, MaxConcurrentStreams defaults to at least 100, per</span>
    <span class="comment">// the HTTP/2 spec&#39;s recommendations.</span>
    MaxConcurrentStreams <a href="godoc.4.html#uint32">uint32</a>

<span id="Server.MaxReadFrameSize"></span>    <span class="comment">// MaxReadFrameSize optionally specifies the largest frame</span>
    <span class="comment">// this server is willing to read. A valid value is between</span>
    <span class="comment">// 16k and 16M, inclusive. If zero or otherwise invalid, a</span>
    <span class="comment">// default value is used.</span>
    MaxReadFrameSize <a href="godoc.4.html#uint32">uint32</a>

<span id="Server.PermitProhibitedCipherSuites"></span>    <span class="comment">// PermitProhibitedCipherSuites, if true, permits the use of</span>
    <span class="comment">// cipher suites prohibited by the HTTP/2 spec.</span>
    PermitProhibitedCipherSuites <a href="godoc.4.html#bool">bool</a>

<span id="Server.IdleTimeout"></span>    <span class="comment">// IdleTimeout specifies how long until idle clients should be</span>
    <span class="comment">// closed with a GOAWAY frame. PING frames are not considered</span>
    <span class="comment">// activity for the purposes of IdleTimeout.</span>
    IdleTimeout <a href="godoc.66.html">time</a>.<a href="godoc.66.html#Duration">Duration</a>

<span id="Server.MaxUploadBufferPerConnection"></span>    <span class="comment">// MaxUploadBufferPerConnection is the size of the initial flow</span>
    <span class="comment">// control window for each connections. The HTTP/2 spec does not</span>
    <span class="comment">// allow this to be smaller than 65535 or larger than 2^32-1.</span>
    <span class="comment">// If the value is outside this range, a default value will be</span>
    <span class="comment">// used instead.</span>
    MaxUploadBufferPerConnection <a href="godoc.4.html#int32">int32</a>

<span id="Server.MaxUploadBufferPerStream"></span>    <span class="comment">// MaxUploadBufferPerStream is the size of the initial flow control</span>
    <span class="comment">// window for each stream. The HTTP/2 spec does not allow this to</span>
    <span class="comment">// be larger than 2^32-1. If the value is zero or larger than the</span>
    <span class="comment">// maximum, a default value will be used instead.</span>
    MaxUploadBufferPerStream <a href="godoc.4.html#int32">int32</a>

<span id="Server.NewWriteScheduler"></span>    <span class="comment">// NewWriteScheduler constructs a write scheduler for a connection.</span>
    <span class="comment">// If nil, a default scheduler is chosen.</span>
    NewWriteScheduler func() <a href="godoc.288.html#WriteScheduler">WriteScheduler</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Server.ServeConn">func (*Server) <a href="http://localhost:6161/src/golang.org/x/net/http2/server.go?s=11614:11673#L354">ServeConn</a>
					<a class="permalink" href="godoc.288.html#Server.ServeConn">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.288.html#Server">Server</a>) ServeConn(c <a href="godoc.14.html">net</a>.<a href="godoc.14.html#Conn">Conn</a>, opts *<a href="godoc.288.html#ServeConnOpts">ServeConnOpts</a>)</pre>
				<p>
ServeConn serves HTTP/2 requests on the provided connection and
blocks until the connection is no longer readable.
</p>
<p>
ServeConn starts speaking HTTP/2 assuming that c has not had any
reads or writes. It writes its initial settings frame and expects
to be able to read the preface and settings frame from the
client. If c has a ConnectionState method like a *tls.Conn, the
ConnectionState is used to verify the TLS ciphersuite and to set
the Request.TLS field in Handlers.
</p>
<p>
ServeConn does not support h2c by itself. Any h2c support must be
implemented in terms of providing a suitably-behaving net.Conn.
</p>
<p>
The opts parameter is optional. If nil, default values are used.
</p>

				
				
				
			
		
			
			
			<h2 id="Setting">type <a href="http://localhost:6161/src/golang.org/x/net/http2/http2.go?s=2778:2945#L104">Setting</a>
				<a class="permalink" href="godoc.288.html#Setting">&#xb6;</a>
				
				
			</h2>
			<p>
Setting is a setting parameter: which setting it is, and its value.
</p>

			<pre>type Setting struct {
<span id="Setting.ID"></span>    <span class="comment">// ID is which setting is being set.</span>
    <span class="comment">// See http://http2.github.io/http2-spec/#SettingValues</span>
    ID <a href="godoc.288.html#SettingID">SettingID</a>

<span id="Setting.Val"></span>    <span class="comment">// Val is the value.</span>
    Val <a href="godoc.4.html#uint32">uint32</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Setting.String">func (Setting) <a href="http://localhost:6161/src/golang.org/x/net/http2/http2.go?s=2947:2979#L113">String</a>
					<a class="permalink" href="godoc.288.html#Setting.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s <a href="godoc.288.html#Setting">Setting</a>) String() <a href="godoc.4.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Setting.Valid">func (Setting) <a href="http://localhost:6161/src/golang.org/x/net/http2/http2.go?s=3078:3108#L118">Valid</a>
					<a class="permalink" href="godoc.288.html#Setting.Valid">&#xb6;</a>
					
					
				</h3>
				<pre>func (s <a href="godoc.288.html#Setting">Setting</a>) Valid() <a href="godoc.4.html#error">error</a></pre>
				<p>
Valid reports whether the setting is valid.
</p>

				
				
				
			
		
			
			
			<h2 id="SettingID">type <a href="http://localhost:6161/src/golang.org/x/net/http2/http2.go?s=3635:3656#L139">SettingID</a>
				<a class="permalink" href="godoc.288.html#SettingID">&#xb6;</a>
				
				
			</h2>
			<p>
A SettingID is an HTTP/2 setting as defined in
<a href="http://http2.github.io/http2-spec/#iana-settings">http://http2.github.io/http2-spec/#iana-settings</a>
</p>

			<pre>type SettingID <a href="godoc.4.html#uint16">uint16</a></pre>

			
				
				<pre>const (
    <span id="SettingHeaderTableSize">SettingHeaderTableSize</span>      <a href="godoc.288.html#SettingID">SettingID</a> = 0x1
    <span id="SettingEnablePush">SettingEnablePush</span>           <a href="godoc.288.html#SettingID">SettingID</a> = 0x2
    <span id="SettingMaxConcurrentStreams">SettingMaxConcurrentStreams</span> <a href="godoc.288.html#SettingID">SettingID</a> = 0x3
    <span id="SettingInitialWindowSize">SettingInitialWindowSize</span>    <a href="godoc.288.html#SettingID">SettingID</a> = 0x4
    <span id="SettingMaxFrameSize">SettingMaxFrameSize</span>         <a href="godoc.288.html#SettingID">SettingID</a> = 0x5
    <span id="SettingMaxHeaderListSize">SettingMaxHeaderListSize</span>    <a href="godoc.288.html#SettingID">SettingID</a> = 0x6
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="SettingID.String">func (SettingID) <a href="http://localhost:6161/src/golang.org/x/net/http2/http2.go?s=4289:4323#L159">String</a>
					<a class="permalink" href="godoc.288.html#SettingID.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s <a href="godoc.288.html#SettingID">SettingID</a>) String() <a href="godoc.4.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="SettingsFrame">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=19770:19822#L683">SettingsFrame</a>
				<a class="permalink" href="godoc.288.html#SettingsFrame">&#xb6;</a>
				
				
			</h2>
			<p>
A SettingsFrame conveys configuration parameters that affect how
endpoints communicate, such as preferences and constraints on peer
behavior.
</p>
<p>
See <a href="http://http2.github.io/http2-spec/#SETTINGS">http://http2.github.io/http2-spec/#SETTINGS</a>
</p>

			<pre>type SettingsFrame struct {
    <a href="godoc.288.html#FrameHeader">FrameHeader</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="SettingsFrame.ForeachSetting">func (*SettingsFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=22589:22657#L781">ForeachSetting</a>
					<a class="permalink" href="godoc.288.html#SettingsFrame.ForeachSetting">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#SettingsFrame">SettingsFrame</a>) ForeachSetting(fn func(<a href="godoc.288.html#Setting">Setting</a>) <a href="godoc.4.html#error">error</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
ForeachSetting runs fn for each setting.
It stops and returns the first error.
</p>

				
				
				
			
				
				<h3 id="SettingsFrame.HasDuplicates">func (*SettingsFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=21946:21990#L749">HasDuplicates</a>
					<a class="permalink" href="godoc.288.html#SettingsFrame.HasDuplicates">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#SettingsFrame">SettingsFrame</a>) HasDuplicates() <a href="godoc.4.html#bool">bool</a></pre>
				<p>
HasDuplicates reports whether f contains any duplicate setting IDs.
</p>

				
				
				
			
				
				<h3 id="SettingsFrame.IsAck">func (*SettingsFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=21181:21217#L722">IsAck</a>
					<a class="permalink" href="godoc.288.html#SettingsFrame.IsAck">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#SettingsFrame">SettingsFrame</a>) IsAck() <a href="godoc.4.html#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="SettingsFrame.NumSettings">func (*SettingsFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=21808:21849#L746">NumSettings</a>
					<a class="permalink" href="godoc.288.html#SettingsFrame.NumSettings">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#SettingsFrame">SettingsFrame</a>) NumSettings() <a href="godoc.4.html#int">int</a></pre>
				
				
				
				
			
				
				<h3 id="SettingsFrame.Setting">func (*SettingsFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=21611:21657#L738">Setting</a>
					<a class="permalink" href="godoc.288.html#SettingsFrame.Setting">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#SettingsFrame">SettingsFrame</a>) Setting(i <a href="godoc.4.html#int">int</a>) <a href="godoc.288.html#Setting">Setting</a></pre>
				<p>
Setting returns the setting from the frame at the given 0-based index.
The index must be &gt;= 0 and less than f.NumSettings().
</p>

				
				
				
			
				
				<h3 id="SettingsFrame.Value">func (*SettingsFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=21272:21335#L726">Value</a>
					<a class="permalink" href="godoc.288.html#SettingsFrame.Value">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#SettingsFrame">SettingsFrame</a>) Value(id <a href="godoc.288.html#SettingID">SettingID</a>) (v <a href="godoc.4.html#uint32">uint32</a>, ok <a href="godoc.4.html#bool">bool</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="StreamError">type <a href="http://localhost:6161/src/golang.org/x/net/http2/errors.go?s=2033:2141#L54">StreamError</a>
				<a class="permalink" href="godoc.288.html#StreamError">&#xb6;</a>
				
				
			</h2>
			<p>
StreamError is an error that only affects one stream within an
HTTP/2 connection.
</p>

			<pre>type StreamError struct {
<span id="StreamError.StreamID"></span>    StreamID <a href="godoc.4.html#uint32">uint32</a>
<span id="StreamError.Code"></span>    Code     <a href="godoc.288.html#ErrCode">ErrCode</a>
<span id="StreamError.Cause"></span>    Cause    <a href="godoc.4.html#error">error</a> <span class="comment">// optional additional detail</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="StreamError.Error">func (StreamError) <a href="http://localhost:6161/src/golang.org/x/net/http2/errors.go?s=2248:2283#L64">Error</a>
					<a class="permalink" href="godoc.288.html#StreamError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e <a href="godoc.288.html#StreamError">StreamError</a>) Error() <a href="godoc.4.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Transport">type <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=1306:3741#L50">Transport</a>
				<a class="permalink" href="godoc.288.html#Transport">&#xb6;</a>
				
				
			</h2>
			<p>
Transport is an HTTP/2 Transport.
</p>
<p>
A Transport internally caches connections to servers. It is safe
for concurrent use by multiple goroutines.
</p>

			<pre>type Transport struct {
<span id="Transport.DialTLS"></span>    <span class="comment">// DialTLS specifies an optional dial function for creating</span>
    <span class="comment">// TLS connections for requests.</span>
    <span class="comment">//</span>
    <span class="comment">// If DialTLS is nil, tls.Dial is used.</span>
    <span class="comment">//</span>
    <span class="comment">// If the returned net.Conn has a ConnectionState method like tls.Conn,</span>
    <span class="comment">// it will be used to set http.Response.TLS.</span>
    DialTLS func(network, addr <a href="godoc.4.html#string">string</a>, cfg *<a href="godoc.337.html">tls</a>.<a href="godoc.337.html#Config">Config</a>) (<a href="godoc.14.html">net</a>.<a href="godoc.14.html#Conn">Conn</a>, <a href="godoc.4.html#error">error</a>)

<span id="Transport.TLSClientConfig"></span>    <span class="comment">// TLSClientConfig specifies the TLS configuration to use with</span>
    <span class="comment">// tls.Client. If nil, the default configuration is used.</span>
    TLSClientConfig *<a href="godoc.337.html">tls</a>.<a href="godoc.337.html#Config">Config</a>

<span id="Transport.ConnPool"></span>    <span class="comment">// ConnPool optionally specifies an alternate connection pool to use.</span>
    <span class="comment">// If nil, the default is used.</span>
    ConnPool <a href="godoc.288.html#ClientConnPool">ClientConnPool</a>

<span id="Transport.DisableCompression"></span>    <span class="comment">// DisableCompression, if true, prevents the Transport from</span>
    <span class="comment">// requesting compression with an &#34;Accept-Encoding: gzip&#34;</span>
    <span class="comment">// request header when the Request contains no existing</span>
    <span class="comment">// Accept-Encoding value. If the Transport requests gzip on</span>
    <span class="comment">// its own and gets a gzipped response, it&#39;s transparently</span>
    <span class="comment">// decoded in the Response.Body. However, if the user</span>
    <span class="comment">// explicitly requested gzip it is not automatically</span>
    <span class="comment">// uncompressed.</span>
    DisableCompression <a href="godoc.4.html#bool">bool</a>

<span id="Transport.AllowHTTP"></span>    <span class="comment">// AllowHTTP, if true, permits HTTP/2 requests using the insecure,</span>
    <span class="comment">// plain-text &#34;http&#34; scheme. Note that this does not enable h2c support.</span>
    AllowHTTP <a href="godoc.4.html#bool">bool</a>

<span id="Transport.MaxHeaderListSize"></span>    <span class="comment">// MaxHeaderListSize is the http2 SETTINGS_MAX_HEADER_LIST_SIZE to</span>
    <span class="comment">// send in the initial settings frame. It is how many bytes</span>
    <span class="comment">// of response headers are allowed. Unlike the http2 spec, zero here</span>
    <span class="comment">// means to use a default limit (currently 10MB). If you actually</span>
    <span class="comment">// want to advertise an ulimited value to the peer, Transport</span>
    <span class="comment">// interprets the highest possible value here (0xffffffff or 1&lt;&lt;32-1)</span>
    <span class="comment">// to mean no limit.</span>
    MaxHeaderListSize <a href="godoc.4.html#uint32">uint32</a>

<span id="Transport.StrictMaxConcurrentStreams"></span>    <span class="comment">// StrictMaxConcurrentStreams controls whether the server&#39;s</span>
    <span class="comment">// SETTINGS_MAX_CONCURRENT_STREAMS should be respected</span>
    <span class="comment">// globally. If false, new TCP connections are created to the</span>
    <span class="comment">// server as needed to keep each under the per-connection</span>
    <span class="comment">// SETTINGS_MAX_CONCURRENT_STREAMS limit. If true, the</span>
    <span class="comment">// server&#39;s SETTINGS_MAX_CONCURRENT_STREAMS is interpreted as</span>
    <span class="comment">// a global limit and callers of RoundTrip block when needed,</span>
    <span class="comment">// waiting for their turn.</span>
    StrictMaxConcurrentStreams <a href="godoc.4.html#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Transport.CloseIdleConnections">func (*Transport) <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=15401:15443#L466">CloseIdleConnections</a>
					<a class="permalink" href="godoc.288.html#Transport.CloseIdleConnections">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="godoc.288.html#Transport">Transport</a>) CloseIdleConnections()</pre>
				<p>
CloseIdleConnections closes any connections which were previously
connected from previous requests but are now sitting idle.
It does not interrupt any connections currently in use.
</p>

				
				
				
			
				
				<h3 id="Transport.NewClientConn">func (*Transport) <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=19220:19286#L596">NewClientConn</a>
					<a class="permalink" href="godoc.288.html#Transport.NewClientConn">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="godoc.288.html#Transport">Transport</a>) NewClientConn(c <a href="godoc.14.html">net</a>.<a href="godoc.14.html#Conn">Conn</a>) (*<a href="godoc.288.html#ClientConn">ClientConn</a>, <a href="godoc.4.html#error">error</a>)</pre>
				
				
				
				
			
				
				<h3 id="Transport.RoundTrip">func (*Transport) <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=13163:13235#L398">RoundTrip</a>
					<a class="permalink" href="godoc.288.html#Transport.RoundTrip">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="godoc.288.html#Transport">Transport</a>) RoundTrip(req *<a href="godoc.16.html">http</a>.<a href="godoc.16.html#Request">Request</a>) (*<a href="godoc.16.html">http</a>.<a href="godoc.16.html#Response">Response</a>, <a href="godoc.4.html#error">error</a>)</pre>
				
				
				
				
			
				
				<h3 id="Transport.RoundTripOpt">func (*Transport) <a href="http://localhost:6161/src/golang.org/x/net/http2/transport.go?s=13965:14058#L424">RoundTripOpt</a>
					<a class="permalink" href="godoc.288.html#Transport.RoundTripOpt">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="godoc.288.html#Transport">Transport</a>) RoundTripOpt(req *<a href="godoc.16.html">http</a>.<a href="godoc.16.html#Request">Request</a>, opt <a href="godoc.288.html#RoundTripOpt">RoundTripOpt</a>) (*<a href="godoc.16.html">http</a>.<a href="godoc.16.html#Response">Response</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
RoundTripOpt is like RoundTrip, but takes options.
</p>

				
				
				
			
		
			
			
			<h2 id="UnknownFrame">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=25731:25782#L890">UnknownFrame</a>
				<a class="permalink" href="godoc.288.html#UnknownFrame">&#xb6;</a>
				
				
			</h2>
			<p>
An UnknownFrame is the frame type returned when the frame type is unknown
or no specific frame type parser exists.
</p>

			<pre>type UnknownFrame struct {
    <a href="godoc.288.html#FrameHeader">FrameHeader</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="UnknownFrame.Payload">func (*UnknownFrame) <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=26065:26104#L900">Payload</a>
					<a class="permalink" href="godoc.288.html#UnknownFrame.Payload">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="godoc.288.html#UnknownFrame">UnknownFrame</a>) Payload() []<a href="godoc.4.html#byte">byte</a></pre>
				<p>
Payload returns the frame&#39;s payload (after the header).  It is not
valid to call this method after a subsequent call to
Framer.ReadFrame, nor is it valid to retain the returned slice.
The memory is owned by the Framer and is invalidated when the next
frame is read.
</p>

				
				
				
			
		
			
			
			<h2 id="WindowUpdateFrame">type <a href="http://localhost:6161/src/golang.org/x/net/http2/frame.go?s=26372:26468#L911">WindowUpdateFrame</a>
				<a class="permalink" href="godoc.288.html#WindowUpdateFrame">&#xb6;</a>
				
				
			</h2>
			<p>
A WindowUpdateFrame is used to implement flow control.
See <a href="http://http2.github.io/http2-spec/#rfc.section.6.9">http://http2.github.io/http2-spec/#rfc.section.6.9</a>
</p>

			<pre>type WindowUpdateFrame struct {
    <a href="godoc.288.html#FrameHeader">FrameHeader</a>
<span id="WindowUpdateFrame.Increment"></span>    Increment <a href="godoc.4.html#uint32">uint32</a> <span class="comment">// never read with high bit set</span>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="WriteScheduler">type <a href="http://localhost:6161/src/golang.org/x/net/http2/writesched.go?s=306:1661#L1">WriteScheduler</a>
				<a class="permalink" href="godoc.288.html#WriteScheduler">&#xb6;</a>
				
				
			</h2>
			<p>
WriteScheduler is the interface implemented by HTTP/2 write schedulers.
Methods are never called concurrently.
</p>

			<pre>type WriteScheduler interface {
    <span class="comment">// OpenStream opens a new stream in the write scheduler.</span>
    <span class="comment">// It is illegal to call this with streamID=0 or with a streamID that is</span>
    <span class="comment">// already open -- the call may panic.</span>
    OpenStream(streamID <a href="godoc.4.html#uint32">uint32</a>, options <a href="godoc.288.html#OpenStreamOptions">OpenStreamOptions</a>)

    <span class="comment">// CloseStream closes a stream in the write scheduler. Any frames queued on</span>
    <span class="comment">// this stream should be discarded. It is illegal to call this on a stream</span>
    <span class="comment">// that is not open -- the call may panic.</span>
    CloseStream(streamID <a href="godoc.4.html#uint32">uint32</a>)

    <span class="comment">// AdjustStream adjusts the priority of the given stream. This may be called</span>
    <span class="comment">// on a stream that has not yet been opened or has been closed. Note that</span>
    <span class="comment">// RFC 7540 allows PRIORITY frames to be sent on streams in any state. See:</span>
    <span class="comment">// https://tools.ietf.org/html/rfc7540#section-5.1</span>
    AdjustStream(streamID <a href="godoc.4.html#uint32">uint32</a>, priority <a href="godoc.288.html#PriorityParam">PriorityParam</a>)

    <span class="comment">// Push queues a frame in the scheduler. In most cases, this will not be</span>
    <span class="comment">// called with wr.StreamID()!=0 unless that stream is currently open. The one</span>
    <span class="comment">// exception is RST_STREAM frames, which may be sent on idle or closed streams.</span>
    Push(wr <a href="godoc.288.html#FrameWriteRequest">FrameWriteRequest</a>)

    <span class="comment">// Pop dequeues the next frame to write. Returns false if no frames can</span>
    <span class="comment">// be written. Frames with a given wr.StreamID() are Pop&#39;d in the same</span>
    <span class="comment">// order they are Push&#39;d. No frames should be discarded except by CloseStream.</span>
    Pop() (wr <a href="godoc.288.html#FrameWriteRequest">FrameWriteRequest</a>, ok <a href="godoc.4.html#bool">bool</a>)
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewPriorityWriteScheduler">func <a href="http://localhost:6161/src/golang.org/x/net/http2/writesched_priority.go?s=2540:2620#L48">NewPriorityWriteScheduler</a>
					<a class="permalink" href="godoc.288.html#NewPriorityWriteScheduler">&#xb6;</a>
					
					
				</h3>
				<pre>func NewPriorityWriteScheduler(cfg *<a href="godoc.288.html#PriorityWriteSchedulerConfig">PriorityWriteSchedulerConfig</a>) <a href="godoc.288.html#WriteScheduler">WriteScheduler</a></pre>
				<p>
NewPriorityWriteScheduler constructs a WriteScheduler that schedules
frames by following HTTP/2 priorities as described in RFC 7540 Section 5.3.
If cfg is nil, default options are used.
</p>

				
				
			
				
				<h3 id="NewRandomWriteScheduler">func <a href="http://localhost:6161/src/golang.org/x/net/http2/writesched_random.go?s=489:534#L3">NewRandomWriteScheduler</a>
					<a class="permalink" href="godoc.288.html#NewRandomWriteScheduler">&#xb6;</a>
					
					
				</h3>
				<pre>func NewRandomWriteScheduler() <a href="godoc.288.html#WriteScheduler">WriteScheduler</a></pre>
				<p>
NewRandomWriteScheduler constructs a WriteScheduler that ignores HTTP/2
priorities. Control frames like SETTINGS and PING are written before DATA
frames, but if no control frames are queued and multiple streams have queued
HEADERS or DATA frames, Pop selects a ready stream arbitrarily.
</p>

				
				
			

			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="godoc.274.html">..</a></td>
			</tr>
			

			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="godoc.289.html">h2c</a>
					</td>
				
					<td class="pkg-synopsis">
						Package h2c implements the unencrypted &#34;h2c&#34; form of HTTP/2.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="godoc.290.html">h2i</a>
					</td>
				
					<td class="pkg-synopsis">
						The h2i command is an interactive HTTP/2 console.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="godoc.291.html">hpack</a>
					</td>
				
					<td class="pkg-synopsis">
						Package hpack implements HPACK, a compression format for efficiently representing HTTP header fields in the context of HTTP/2.
					</td>
				</tr>
			
		</table>
	</div>



<div id="footer">
Build version go1.13.5.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6161/LICENSE">BSD license</a>.<br>
<a href="http://localhost:6161/doc/tos.html">Terms of Service</a> |
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
