<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>tlog - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="style.css">

<script>window.initFuncs = [];</script>
<script src="jquery.js" defer></script>



<script>var goVersion = "go1.13.5";</script>
<script src="godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="godoc.588.html">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="godoc.588.html">GoDoc</a></div>
<a href="godoc.272.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6161/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package tlog
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "golang.org/x/mod/sumdb/tlog"</code></dd>
			</dl>
			<dl>
			<dd><a href="godoc.272.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="godoc.272.html#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package tlog implements a tamper-evident log
used in the Go module go.sum database server.
</p>
<p>
This package follows the design of Certificate Transparency (RFC 6962)
and its proofs are compatible with that system.
See TestCertificateTransparency.
</p>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="godoc.272.html#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="godoc.272.html#CheckRecord">func CheckRecord(p RecordProof, t int64, th Hash, n int64, h Hash) error</a></dd>
			
				
				<dd><a href="godoc.272.html#CheckTree">func CheckTree(p TreeProof, t int64, th Hash, n int64, h Hash) error</a></dd>
			
				
				<dd><a href="godoc.272.html#FormatRecord">func FormatRecord(id int64, text []byte) (msg []byte, err error)</a></dd>
			
				
				<dd><a href="godoc.272.html#FormatTree">func FormatTree(tree Tree) []byte</a></dd>
			
				
				<dd><a href="godoc.272.html#ParseRecord">func ParseRecord(msg []byte) (id int64, text, rest []byte, err error)</a></dd>
			
				
				<dd><a href="godoc.272.html#ReadTileData">func ReadTileData(t Tile, r HashReader) ([]byte, error)</a></dd>
			
				
				<dd><a href="godoc.272.html#SplitStoredHashIndex">func SplitStoredHashIndex(index int64) (level int, n int64)</a></dd>
			
				
				<dd><a href="godoc.272.html#StoredHashCount">func StoredHashCount(n int64) int64</a></dd>
			
				
				<dd><a href="godoc.272.html#StoredHashIndex">func StoredHashIndex(level int, n int64) int64</a></dd>
			
			
				
				<dd><a href="godoc.272.html#Hash">type Hash</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#HashFromTile">func HashFromTile(t Tile, data []byte, index int64) (Hash, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#NodeHash">func NodeHash(left, right Hash) Hash</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#ParseHash">func ParseHash(s string) (Hash, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#RecordHash">func RecordHash(data []byte) Hash</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#StoredHashes">func StoredHashes(n int64, data []byte, r HashReader) ([]Hash, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#StoredHashesForRecordHash">func StoredHashesForRecordHash(n int64, h Hash, r HashReader) ([]Hash, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#TreeHash">func TreeHash(n int64, r HashReader) (Hash, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#Hash.MarshalJSON">func (h Hash) MarshalJSON() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#Hash.String">func (h Hash) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#Hash.UnmarshalJSON">func (h *Hash) UnmarshalJSON(data []byte) error</a></dd>
				
			
				
				<dd><a href="godoc.272.html#HashReader">type HashReader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#TileHashReader">func TileHashReader(tree Tree, tr TileReader) HashReader</a></dd>
				
				
			
				
				<dd><a href="godoc.272.html#HashReaderFunc">type HashReaderFunc</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#HashReaderFunc.ReadHashes">func (f HashReaderFunc) ReadHashes(indexes []int64) ([]Hash, error)</a></dd>
				
			
				
				<dd><a href="godoc.272.html#RecordProof">type RecordProof</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#ProveRecord">func ProveRecord(t, n int64, r HashReader) (RecordProof, error)</a></dd>
				
				
			
				
				<dd><a href="godoc.272.html#Tile">type Tile</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#NewTiles">func NewTiles(h int, oldTreeSize, newTreeSize int64) []Tile</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#ParseTilePath">func ParseTilePath(path string) (Tile, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#TileForIndex">func TileForIndex(h int, index int64) Tile</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#Tile.Path">func (t Tile) Path() string</a></dd>
				
			
				
				<dd><a href="godoc.272.html#TileReader">type TileReader</a></dd>
				
				
			
				
				<dd><a href="godoc.272.html#Tree">type Tree</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#ParseTree">func ParseTree(text []byte) (tree Tree, err error)</a></dd>
				
				
			
				
				<dd><a href="godoc.272.html#TreeProof">type TreeProof</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.272.html#ProveTree">func ProveTree(t, n int64, h HashReader) (TreeProof, error)</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/note.go">note.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tile.go">tile.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go">tlog.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>
HashSize is the size of a Hash in bytes.
</p>

				<pre>const <span id="HashSize">HashSize</span> = 32</pre>
			
		
		
		
			
			
			<h2 id="CheckRecord">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=12578:12650#L385">CheckRecord</a>
				<a class="permalink" href="godoc.272.html#CheckRecord">&#xb6;</a>
				
				
			</h2>
			<pre>func CheckRecord(p <a href="godoc.272.html#RecordProof">RecordProof</a>, t <a href="godoc.4.html#int64">int64</a>, th <a href="godoc.272.html#Hash">Hash</a>, n <a href="godoc.4.html#int64">int64</a>, h <a href="godoc.272.html#Hash">Hash</a>) <a href="godoc.4.html#error">error</a></pre>
			<p>
CheckRecord verifies that p is a valid proof that the tree of size t
with hash th has an n&#39;th record with hash h.
</p>

			
			

		
			
			
			<h2 id="CheckTree">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=16762:16830#L531">CheckTree</a>
				<a class="permalink" href="godoc.272.html#CheckTree">&#xb6;</a>
				
				
			</h2>
			<pre>func CheckTree(p <a href="godoc.272.html#TreeProof">TreeProof</a>, t <a href="godoc.4.html#int64">int64</a>, th <a href="godoc.272.html#Hash">Hash</a>, n <a href="godoc.4.html#int64">int64</a>, h <a href="godoc.272.html#Hash">Hash</a>) <a href="godoc.4.html#error">error</a></pre>
			<p>
CheckTree verifies that p is a valid proof that the tree of size t with hash th
contains as a prefix the tree of size n with hash h.
</p>

			
			

		
			
			
			<h2 id="FormatRecord">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/note.go?s=2401:2465#L73">FormatRecord</a>
				<a class="permalink" href="godoc.272.html#FormatRecord">&#xb6;</a>
				
				
			</h2>
			<pre>func FormatRecord(id <a href="godoc.4.html#int64">int64</a>, text []<a href="godoc.4.html#byte">byte</a>) (msg []<a href="godoc.4.html#byte">byte</a>, err <a href="godoc.4.html#error">error</a>)</pre>
			<p>
FormatRecord formats a record for serving to a client
in a lookup response or data tile.
</p>
<p>
The encoded form is the record ID as a single number,
then the text of the record, and then a terminating blank line.
Record text must be valid UTF-8 and must not contain any ASCII control
characters (those below U+0020) other than newline (U+000A).
It must end in a terminating newline and not contain any blank lines.
</p>

			
			

		
			
			
			<h2 id="FormatTree">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/note.go?s=845:878#L27">FormatTree</a>
				<a class="permalink" href="godoc.272.html#FormatTree">&#xb6;</a>
				
				
			</h2>
			<pre>func FormatTree(tree <a href="godoc.272.html#Tree">Tree</a>) []<a href="godoc.4.html#byte">byte</a></pre>
			<p>
FormatTree formats a tree description for inclusion in a note.
</p>
<p>
The encoded form is three lines, each ending in a newline (U+000A):
</p>
<pre>go.sum database tree
N
Hash
</pre>
<p>
where N is in decimal and Hash is in base64.
</p>
<p>
A future backwards-compatible encoding may add additional lines,
which the parser can ignore.
A future backwards-incompatible encoding would use a different
first line (for example, &#34;go.sum database tree v2&#34;).
</p>

			
			

		
			
			
			<h2 id="ParseRecord">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/note.go?s=3241:3310#L103">ParseRecord</a>
				<a class="permalink" href="godoc.272.html#ParseRecord">&#xb6;</a>
				
				
			</h2>
			<pre>func ParseRecord(msg []<a href="godoc.4.html#byte">byte</a>) (id <a href="godoc.4.html#int64">int64</a>, text, rest []<a href="godoc.4.html#byte">byte</a>, err <a href="godoc.4.html#error">error</a>)</pre>
			<p>
ParseRecord parses a record description at the start of text,
stopping immediately after the terminating blank line.
It returns the record id, the record text, and the remainder of text.
</p>

			
			

		
			
			
			<h2 id="ReadTileData">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tile.go?s=4629:4684#L126">ReadTileData</a>
				<a class="permalink" href="godoc.272.html#ReadTileData">&#xb6;</a>
				
				
			</h2>
			<pre>func ReadTileData(t <a href="godoc.272.html#Tile">Tile</a>, r <a href="godoc.272.html#HashReader">HashReader</a>) ([]<a href="godoc.4.html#byte">byte</a>, <a href="godoc.4.html#error">error</a>)</pre>
			<p>
ReadTileData reads the hashes for tile t from r
and returns the corresponding tile data.
</p>

			
			

		
			
			
			<h2 id="SplitStoredHashIndex">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=4219:4278#L127">SplitStoredHashIndex</a>
				<a class="permalink" href="godoc.272.html#SplitStoredHashIndex">&#xb6;</a>
				
				
			</h2>
			<pre>func SplitStoredHashIndex(index <a href="godoc.4.html#int64">int64</a>) (level <a href="godoc.4.html#int">int</a>, n <a href="godoc.4.html#int64">int64</a>)</pre>
			<p>
SplitStoredHashIndex is the inverse of StoredHashIndex.
That is, SplitStoredHashIndex(StoredHashIndex(level, n)) == level, n.
</p>

			
			

		
			
			
			<h2 id="StoredHashCount">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=4961:4996#L153">StoredHashCount</a>
				<a class="permalink" href="godoc.272.html#StoredHashCount">&#xb6;</a>
				
				
			</h2>
			<pre>func StoredHashCount(n <a href="godoc.4.html#int64">int64</a>) <a href="godoc.4.html#int64">int64</a></pre>
			<p>
StoredHashCount returns the number of stored hashes
that are expected for a tree with n records.
</p>

			
			

		
			
			
			<h2 id="StoredHashIndex">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=3651:3697#L108">StoredHashIndex</a>
				<a class="permalink" href="godoc.272.html#StoredHashIndex">&#xb6;</a>
				
				
			</h2>
			<pre>func StoredHashIndex(level <a href="godoc.4.html#int">int</a>, n <a href="godoc.4.html#int64">int64</a>) <a href="godoc.4.html#int64">int64</a></pre>
			<p>
StoredHashIndex maps the tree coordinates (level, n)
to a dense linear ordering that can be used for hash storage.
Hash storage implementations that store hashes in sequential
storage can use this function to compute where to read or write
a given hash.
</p>

			
			

		
		
			
			
			<h2 id="Hash">type <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=575:599#L13">Hash</a>
				<a class="permalink" href="godoc.272.html#Hash">&#xb6;</a>
				
				
			</h2>
			<p>
A Hash is a hash identifying a log record or tree root.
</p>

			<pre>type Hash [<a href="godoc.272.html#HashSize">HashSize</a>]<a href="godoc.4.html#byte">byte</a></pre>

			

			

			
			
			

			
				
				<h3 id="HashFromTile">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tile.go?s=2732:2797#L65">HashFromTile</a>
					<a class="permalink" href="godoc.272.html#HashFromTile">&#xb6;</a>
					
					
				</h3>
				<pre>func HashFromTile(t <a href="godoc.272.html#Tile">Tile</a>, data []<a href="godoc.4.html#byte">byte</a>, index <a href="godoc.4.html#int64">int64</a>) (<a href="godoc.272.html#Hash">Hash</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
HashFromTile returns the hash at the given storage index,
provided that t == TileForIndex(t.H, index) or a wider version,
and data is t&#39;s tile data (of length at least t.W*HashSize).
</p>

				
				
			
				
				<h3 id="NodeHash">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=2765:2801#L86">NodeHash</a>
					<a class="permalink" href="godoc.272.html#NodeHash">&#xb6;</a>
					
					
				</h3>
				<pre>func NodeHash(left, right <a href="godoc.272.html#Hash">Hash</a>) <a href="godoc.272.html#Hash">Hash</a></pre>
				<p>
NodeHash returns the hash for an interior tree node with the given left and right hashes.
</p>

				
				
			
				
				<h3 id="ParseHash">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=1925:1963#L51">ParseHash</a>
					<a class="permalink" href="godoc.272.html#ParseHash">&#xb6;</a>
					
					
				</h3>
				<pre>func ParseHash(s <a href="godoc.4.html#string">string</a>) (<a href="godoc.272.html#Hash">Hash</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
ParseHash parses the base64-encoded string form of a hash.
</p>

				
				
			
				
				<h3 id="RecordHash">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=2462:2495#L74">RecordHash</a>
					<a class="permalink" href="godoc.272.html#RecordHash">&#xb6;</a>
					
					
				</h3>
				<pre>func RecordHash(data []<a href="godoc.4.html#byte">byte</a>) <a href="godoc.272.html#Hash">Hash</a></pre>
				<p>
RecordHash returns the content hash for the given record data.
</p>

				
				
			
				
				<h3 id="StoredHashes">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=5690:5759#L173">StoredHashes</a>
					<a class="permalink" href="godoc.272.html#StoredHashes">&#xb6;</a>
					
					
				</h3>
				<pre>func StoredHashes(n <a href="godoc.4.html#int64">int64</a>, data []<a href="godoc.4.html#byte">byte</a>, r <a href="godoc.272.html#HashReader">HashReader</a>) ([]<a href="godoc.272.html#Hash">Hash</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
StoredHashes returns the hashes that must be stored when writing
record n with the given data. The hashes should be stored starting
at StoredHashIndex(0, n). The result will have at most 1 + log₂ n hashes,
but it will average just under two per call for a sequence of calls for n=1..k.
</p>
<p>
StoredHashes may read up to log n earlier hashes from r
in order to compute hashes for completed subtrees.
</p>

				
				
			
				
				<h3 id="StoredHashesForRecordHash">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=5950:6027#L179">StoredHashesForRecordHash</a>
					<a class="permalink" href="godoc.272.html#StoredHashesForRecordHash">&#xb6;</a>
					
					
				</h3>
				<pre>func StoredHashesForRecordHash(n <a href="godoc.4.html#int64">int64</a>, h <a href="godoc.272.html#Hash">Hash</a>, r <a href="godoc.272.html#HashReader">HashReader</a>) ([]<a href="godoc.272.html#Hash">Hash</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
StoredHashesForRecordHash is like StoredHashes but takes
as its second argument RecordHash(data) instead of data itself.
</p>

				
				
			
				
				<h3 id="TreeHash">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=7875:7925#L233">TreeHash</a>
					<a class="permalink" href="godoc.272.html#TreeHash">&#xb6;</a>
					
					
				</h3>
				<pre>func TreeHash(n <a href="godoc.4.html#int64">int64</a>, r <a href="godoc.272.html#HashReader">HashReader</a>) (<a href="godoc.272.html#Hash">Hash</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
TreeHash computes the hash for the root of the tree with n records,
using the HashReader to obtain previously stored hashes
(those returned by StoredHashes during the writes of those n records).
TreeHash makes a single call to ReadHash requesting at most 1 + log₂ n hashes.
The tree of size zero is defined to have an all-zero Hash.
</p>

				
				
			

			
				
				<h3 id="Hash.MarshalJSON">func (Hash) <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=903:946#L24">MarshalJSON</a>
					<a class="permalink" href="godoc.272.html#Hash.MarshalJSON">&#xb6;</a>
					
					
				</h3>
				<pre>func (h <a href="godoc.272.html#Hash">Hash</a>) MarshalJSON() ([]<a href="godoc.4.html#byte">byte</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
MarshalJSON marshals the hash as a JSON string containing the base64-encoded hash.
</p>

				
				
				
			
				
				<h3 id="Hash.String">func (Hash) <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=734:763#L19">String</a>
					<a class="permalink" href="godoc.272.html#Hash.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (h <a href="godoc.272.html#Hash">Hash</a>) String() <a href="godoc.4.html#string">string</a></pre>
				<p>
String returns a base64 representation of the hash for printing.
</p>

				
				
				
			
				
				<h3 id="Hash.UnmarshalJSON">func (*Hash) <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=1086:1133#L29">UnmarshalJSON</a>
					<a class="permalink" href="godoc.272.html#Hash.UnmarshalJSON">&#xb6;</a>
					
					
				</h3>
				<pre>func (h *<a href="godoc.272.html#Hash">Hash</a>) UnmarshalJSON(data []<a href="godoc.4.html#byte">byte</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
UnmarshalJSON unmarshals a hash from JSON string containing the a base64-encoded hash.
</p>

				
				
				
			
		
			
			
			<h2 id="HashReader">type <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=6937:7321#L212">HashReader</a>
				<a class="permalink" href="godoc.272.html#HashReader">&#xb6;</a>
				
				
			</h2>
			<p>
A HashReader can read hashes for nodes in the log&#39;s tree structure.
</p>

			<pre>type HashReader interface {
    <span class="comment">// ReadHashes returns the hashes with the given stored hash indexes</span>
    <span class="comment">// (see StoredHashIndex and SplitStoredHashIndex).</span>
    <span class="comment">// ReadHashes must return a slice of hashes the same length as indexes,</span>
    <span class="comment">// or else it must return a non-nil error.</span>
    <span class="comment">// ReadHashes may run faster if indexes is sorted in increasing order.</span>
    ReadHashes(indexes []<a href="godoc.4.html#int64">int64</a>) ([]<a href="godoc.272.html#Hash">Hash</a>, <a href="godoc.4.html#error">error</a>)
}</pre>

			

			

			
			
			

			
				
				<h3 id="TileHashReader">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tile.go?s=8697:8753#L268">TileHashReader</a>
					<a class="permalink" href="godoc.272.html#TileHashReader">&#xb6;</a>
					
					
				</h3>
				<pre>func TileHashReader(tree <a href="godoc.272.html#Tree">Tree</a>, tr <a href="godoc.272.html#TileReader">TileReader</a>) <a href="godoc.272.html#HashReader">HashReader</a></pre>
				<p>
TileHashReader returns a HashReader that satisfies requests
by loading tiles of the given tree.
</p>
<p>
The returned HashReader checks that loaded tiles are
valid for the given tree. Therefore, any hashes returned
by the HashReader are already proven to be in the tree.
</p>

				
				
			

			
		
			
			
			<h2 id="HashReaderFunc">type <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=7382:7431#L222">HashReaderFunc</a>
				<a class="permalink" href="godoc.272.html#HashReaderFunc">&#xb6;</a>
				
				
			</h2>
			<p>
A HashReaderFunc is a function implementing HashReader.
</p>

			<pre>type HashReaderFunc func([]<a href="godoc.4.html#int64">int64</a>) ([]<a href="godoc.272.html#Hash">Hash</a>, <a href="godoc.4.html#error">error</a>)</pre>

			

			

			
			
			

			

			
				
				<h3 id="HashReaderFunc.ReadHashes">func (HashReaderFunc) <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=7433:7500#L224">ReadHashes</a>
					<a class="permalink" href="godoc.272.html#HashReaderFunc.ReadHashes">&#xb6;</a>
					
					
				</h3>
				<pre>func (f <a href="godoc.272.html#HashReaderFunc">HashReaderFunc</a>) ReadHashes(indexes []<a href="godoc.4.html#int64">int64</a>) ([]<a href="godoc.272.html#Hash">Hash</a>, <a href="godoc.4.html#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="RecordProof">type <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=9957:9980#L302">RecordProof</a>
				<a class="permalink" href="godoc.272.html#RecordProof">&#xb6;</a>
				
				
			</h2>
			<p>
A RecordProof is a verifiable proof that a particular log root contains a particular record.
RFC 6962 calls this a &ldquo;Merkle audit path.&rdquo;
</p>

			<pre>type RecordProof []<a href="godoc.272.html#Hash">Hash</a></pre>

			

			

			
			
			

			
				
				<h3 id="ProveRecord">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=10073:10136#L305">ProveRecord</a>
					<a class="permalink" href="godoc.272.html#ProveRecord">&#xb6;</a>
					
					
				</h3>
				<pre>func ProveRecord(t, n <a href="godoc.4.html#int64">int64</a>, r <a href="godoc.272.html#HashReader">HashReader</a>) (<a href="godoc.272.html#RecordProof">RecordProof</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
ProveRecord returns the proof that the tree of size t contains the record with index n.
</p>

				
				
			

			
		
			
			
			<h2 id="Tile">type <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tile.go?s=1443:1674#L29">Tile</a>
				<a class="permalink" href="godoc.272.html#Tile">&#xb6;</a>
				
				
			</h2>
			<p>
A Tile is a description of a transparency log tile.
A tile of height H at level L offset N lists W consecutive hashes
at level H*L of the tree starting at offset N*(2**H).
A complete tile lists 2**H hashes; a partial tile lists fewer.
Note that a tile represents the entire subtree of height H
with those hashes as the leaves. The levels above H*L
can be reconstructed by hashing the leaves.
</p>
<p>
Each Tile can be encoded as a &ldquo;tile coordinate path&rdquo;
of the form tile/H/L/NNN[.p/W].
The .p/W suffix is present only for partial tiles, meaning W &lt; 2**H.
The NNN element is an encoding of N into 3-digit path elements.
All but the last path element begins with an &#34;x&#34;.
For example,
Tile{H: 3, L: 4, N: 1234067, W: 1}&#39;s path
is tile/3/4/x001/x234/067.p/1, and
Tile{H: 3, L: 4, N: 1234067, W: 8}&#39;s path
is tile/3/4/x001/x234/067.
See Tile&#39;s Path method and the ParseTilePath function.
</p>
<p>
The special level L=-1 holds raw record data instead of hashes.
In this case, the level encodes into a tile path as the path element
&#34;data&#34; instead of &#34;-1&#34;.
</p>
<p>
See also <a href="https://golang.org/design/25530-sumdb#checksum-database">https://golang.org/design/25530-sumdb#checksum-database</a>
and <a href="https://research.swtch.com/tlog#tiling_a_log">https://research.swtch.com/tlog#tiling_a_log</a>.
</p>

			<pre>type Tile struct {
<span id="Tile.H"></span>    H <a href="godoc.4.html#int">int</a>   <span class="comment">// height of tile (1 ≤ H ≤ 30)</span>
<span id="Tile.L"></span>    L <a href="godoc.4.html#int">int</a>   <span class="comment">// level in tiling (-1 ≤ L ≤ 63)</span>
<span id="Tile.N"></span>    N <a href="godoc.4.html#int64">int64</a> <span class="comment">// number within level (0 ≤ N, unbounded)</span>
<span id="Tile.W"></span>    W <a href="godoc.4.html#int">int</a>   <span class="comment">// width of tile (1 ≤ W ≤ 2**H; 2**H is complete tile)</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewTiles">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tile.go?s=3892:3951#L99">NewTiles</a>
					<a class="permalink" href="godoc.272.html#NewTiles">&#xb6;</a>
					
					
				</h3>
				<pre>func NewTiles(h <a href="godoc.4.html#int">int</a>, oldTreeSize, newTreeSize <a href="godoc.4.html#int64">int64</a>) []<a href="godoc.272.html#Tile">Tile</a></pre>
				<p>
NewTiles returns the coordinates of the tiles of height h ≥ 1
that must be published when publishing from a tree of
size newTreeSize to replace a tree of size oldTreeSize.
(No tiles need to be published for a tree of size zero.)
</p>
<p>
If h ≤ 0, TileForIndex panics.
</p>

				
				
			
				
				<h3 id="ParseTilePath">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tile.go?s=6077:6122#L182">ParseTilePath</a>
					<a class="permalink" href="godoc.272.html#ParseTilePath">&#xb6;</a>
					
					
				</h3>
				<pre>func ParseTilePath(path <a href="godoc.4.html#string">string</a>) (<a href="godoc.272.html#Tile">Tile</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
ParseTilePath parses a tile coordinate path.
</p>

				
				
			
				
				<h3 id="TileForIndex">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tile.go?s=1829:1871#L40">TileForIndex</a>
					<a class="permalink" href="godoc.272.html#TileForIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func TileForIndex(h <a href="godoc.4.html#int">int</a>, index <a href="godoc.4.html#int64">int64</a>) <a href="godoc.272.html#Tile">Tile</a></pre>
				<p>
TileForIndex returns the tile of fixed height h ≥ 1
and least width storing the given hash storage index.
</p>
<p>
If h ≤ 0, TileForIndex panics.
</p>

				
				
			

			
				
				<h3 id="Tile.Path">func (Tile) <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tile.go?s=5634:5661#L161">Path</a>
					<a class="permalink" href="godoc.272.html#Tile.Path">&#xb6;</a>
					
					
				</h3>
				<pre>func (t <a href="godoc.272.html#Tile">Tile</a>) Path() <a href="godoc.4.html#string">string</a></pre>
				<p>
Path returns a tile coordinate path describing t.
</p>

				
				
				
			
		
			
			
			<h2 id="TileReader">type <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tile.go?s=7295:8415#L235">TileReader</a>
				<a class="permalink" href="godoc.272.html#TileReader">&#xb6;</a>
				
				
			</h2>
			<p>
A TileReader reads tiles from a go.sum database log.
</p>

			<pre>type TileReader interface {
    <span class="comment">// Height returns the height of the available tiles.</span>
    Height() <a href="godoc.4.html#int">int</a>

    <span class="comment">// ReadTiles returns the data for each requested tile.</span>
    <span class="comment">// If ReadTiles returns err == nil, it must also return</span>
    <span class="comment">// a data record for each tile (len(data) == len(tiles))</span>
    <span class="comment">// and each data record must be the correct length</span>
    <span class="comment">// (len(data[i]) == tiles[i].W*HashSize).</span>
    <span class="comment">//</span>
    <span class="comment">// An implementation of ReadTiles typically reads</span>
    <span class="comment">// them from an on-disk cache or else from a remote</span>
    <span class="comment">// tile server. Tile data downloaded from a server should</span>
    <span class="comment">// be considered suspect and not saved into a persistent</span>
    <span class="comment">// on-disk cache before returning from ReadTiles.</span>
    <span class="comment">// When the client confirms the validity of the tile data,</span>
    <span class="comment">// it will call SaveTiles to signal that they can be safely</span>
    <span class="comment">// written to persistent storage.</span>
    <span class="comment">// See also https://research.swtch.com/tlog#authenticating_tiles.</span>
    ReadTiles(tiles []<a href="godoc.272.html#Tile">Tile</a>) (data [][]<a href="godoc.4.html#byte">byte</a>, err <a href="godoc.4.html#error">error</a>)

    <span class="comment">// SaveTiles informs the TileReader that the tile data</span>
    <span class="comment">// returned by ReadTiles has been confirmed as valid</span>
    <span class="comment">// and can be saved in persistent storage (on disk).</span>
    SaveTiles(tiles []<a href="godoc.272.html#Tile">Tile</a>, data [][]<a href="godoc.4.html#byte">byte</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Tree">type <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/note.go?s=344:387#L8">Tree</a>
				<a class="permalink" href="godoc.272.html#Tree">&#xb6;</a>
				
				
			</h2>
			<p>
A Tree is a tree description, to be signed by a go.sum database server.
</p>

			<pre>type Tree struct {
<span id="Tree.N"></span>    N    <a href="godoc.4.html#int64">int64</a>
<span id="Tree.Hash"></span>    Hash <a href="godoc.272.html#Hash">Hash</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="ParseTree">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/note.go?s=1128:1178#L35">ParseTree</a>
					<a class="permalink" href="godoc.272.html#ParseTree">&#xb6;</a>
					
					
				</h3>
				<pre>func ParseTree(text []<a href="godoc.4.html#byte">byte</a>) (tree <a href="godoc.272.html#Tree">Tree</a>, err <a href="godoc.4.html#error">error</a>)</pre>
				<p>
ParseTree parses a formatted tree root description.
</p>

				
				
			

			
		
			
			
			<h2 id="TreeProof">type <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=14075:14096#L440">TreeProof</a>
				<a class="permalink" href="godoc.272.html#TreeProof">&#xb6;</a>
				
				
			</h2>
			<p>
A TreeProof is a verifiable proof that a particular log tree contains
as a prefix all records present in an earlier tree.
RFC 6962 calls this a &ldquo;Merkle consistency proof.&rdquo;
</p>

			<pre>type TreeProof []<a href="godoc.272.html#Hash">Hash</a></pre>

			

			

			
			
			

			
				
				<h3 id="ProveTree">func <a href="http://localhost:6161/src/golang.org/x/mod/sumdb/tlog/tlog.go?s=14226:14285#L444">ProveTree</a>
					<a class="permalink" href="godoc.272.html#ProveTree">&#xb6;</a>
					
					
				</h3>
				<pre>func ProveTree(t, n <a href="godoc.4.html#int64">int64</a>, h <a href="godoc.272.html#HashReader">HashReader</a>) (<a href="godoc.272.html#TreeProof">TreeProof</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
ProveTree returns the proof that the tree of size t contains
as a prefix all the records from the tree of smaller size n.
</p>

				
				
			

			
		
	

	







<div id="footer">
Build version go1.13.5.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6161/LICENSE">BSD license</a>.<br>
<a href="http://localhost:6161/doc/tos.html">Terms of Service</a> |
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
