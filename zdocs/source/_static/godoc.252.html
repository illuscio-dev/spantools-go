<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>ssh - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="style.css">

<script>window.initFuncs = [];</script>
<script src="jquery.js" defer></script>



<script>var goVersion = "go1.13.5";</script>
<script src="godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="godoc.588.html">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="godoc.588.html">GoDoc</a></div>
<a href="godoc.252.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6161/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package ssh
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "golang.org/x/crypto/ssh"</code></dd>
			</dl>
			<dl>
			<dd><a href="godoc.252.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="godoc.252.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="godoc.252.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="godoc.252.html#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package ssh implements an SSH client and server.
</p>
<p>
SSH is a transport security protocol, an authentication protocol and a
family of application protocols. The most typical application level
protocol is a remote shell and this is specifically implemented.  However,
the multiplexed nature of SSH is exposed to users that wish to support
others.
</p>
<p>
References:
</p>
<pre>[PROTOCOL.certkeys]: <a href="http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.bin/ssh/PROTOCOL.certkeys?rev=HEAD">http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.bin/ssh/PROTOCOL.certkeys?rev=HEAD</a>
[SSH-PARAMETERS]:    <a href="http://www.iana.org/assignments/ssh-parameters/ssh-parameters.xml#ssh-parameters-1">http://www.iana.org/assignments/ssh-parameters/ssh-parameters.xml#ssh-parameters-1</a>
</pre>
<p>
This package does not fall under the stability promise of the Go language itself,
so its API may be changed when pressing needs arise.
</p>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="godoc.252.html#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="godoc.252.html#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="godoc.252.html#DiscardRequests">func DiscardRequests(in &lt;-chan *Request)</a></dd>
			
				
				<dd><a href="godoc.252.html#FingerprintLegacyMD5">func FingerprintLegacyMD5(pubKey PublicKey) string</a></dd>
			
				
				<dd><a href="godoc.252.html#FingerprintSHA256">func FingerprintSHA256(pubKey PublicKey) string</a></dd>
			
				
				<dd><a href="godoc.252.html#Marshal">func Marshal(msg interface{}) []byte</a></dd>
			
				
				<dd><a href="godoc.252.html#MarshalAuthorizedKey">func MarshalAuthorizedKey(key PublicKey) []byte</a></dd>
			
				
				<dd><a href="godoc.252.html#ParseDSAPrivateKey">func ParseDSAPrivateKey(der []byte) (*dsa.PrivateKey, error)</a></dd>
			
				
				<dd><a href="godoc.252.html#ParseRawPrivateKey">func ParseRawPrivateKey(pemBytes []byte) (interface{}, error)</a></dd>
			
				
				<dd><a href="godoc.252.html#ParseRawPrivateKeyWithPassphrase">func ParseRawPrivateKeyWithPassphrase(pemBytes, passPhrase []byte) (interface{}, error)</a></dd>
			
				
				<dd><a href="godoc.252.html#Unmarshal">func Unmarshal(data []byte, out interface{}) error</a></dd>
			
			
				
				<dd><a href="godoc.252.html#AlgorithmSigner">type AlgorithmSigner</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#AuthMethod">type AuthMethod</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#GSSAPIWithMICAuthMethod">func GSSAPIWithMICAuthMethod(gssAPIClient GSSAPIClient, target string) AuthMethod</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#KeyboardInteractive">func KeyboardInteractive(challenge KeyboardInteractiveChallenge) AuthMethod</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Password">func Password(secret string) AuthMethod</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#PasswordCallback">func PasswordCallback(prompt func() (secret string, err error)) AuthMethod</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#PublicKeys">func PublicKeys(signers ...Signer) AuthMethod</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#PublicKeysCallback">func PublicKeysCallback(getSigners func() (signers []Signer, err error)) AuthMethod</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#RetryableAuthMethod">func RetryableAuthMethod(auth AuthMethod, maxTries int) AuthMethod</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#BannerCallback">type BannerCallback</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#BannerDisplayStderr">func BannerDisplayStderr() BannerCallback</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#CertChecker">type CertChecker</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#CertChecker.Authenticate">func (c *CertChecker) Authenticate(conn ConnMetadata, pubKey PublicKey) (*Permissions, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#CertChecker.CheckCert">func (c *CertChecker) CheckCert(principal string, cert *Certificate) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#CertChecker.CheckHostKey">func (c *CertChecker) CheckHostKey(addr string, remote net.Addr, key PublicKey) error</a></dd>
				
			
				
				<dd><a href="godoc.252.html#Certificate">type Certificate</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Certificate.Marshal">func (c *Certificate) Marshal() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Certificate.SignCert">func (c *Certificate) SignCert(rand io.Reader, authority Signer) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Certificate.Type">func (c *Certificate) Type() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Certificate.Verify">func (c *Certificate) Verify(data []byte, sig *Signature) error</a></dd>
				
			
				
				<dd><a href="godoc.252.html#Channel">type Channel</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#Client">type Client</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Dial">func Dial(network, addr string, config *ClientConfig) (*Client, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#NewClient">func NewClient(c Conn, chans &lt;-chan NewChannel, reqs &lt;-chan *Request) *Client</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Client.Dial">func (c *Client) Dial(n, addr string) (net.Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Client.DialTCP">func (c *Client) DialTCP(n string, laddr, raddr *net.TCPAddr) (net.Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Client.HandleChannelOpen">func (c *Client) HandleChannelOpen(channelType string) &lt;-chan NewChannel</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Client.Listen">func (c *Client) Listen(n, addr string) (net.Listener, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Client.ListenTCP">func (c *Client) ListenTCP(laddr *net.TCPAddr) (net.Listener, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Client.ListenUnix">func (c *Client) ListenUnix(socketPath string) (net.Listener, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Client.NewSession">func (c *Client) NewSession() (*Session, error)</a></dd>
				
			
				
				<dd><a href="godoc.252.html#ClientConfig">type ClientConfig</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#Config">type Config</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Config.SetDefaults">func (c *Config) SetDefaults()</a></dd>
				
			
				
				<dd><a href="godoc.252.html#Conn">type Conn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#NewClientConn">func NewClientConn(c net.Conn, addr string, config *ClientConfig) (Conn, &lt;-chan NewChannel, &lt;-chan *Request, error)</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#ConnMetadata">type ConnMetadata</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#CryptoPublicKey">type CryptoPublicKey</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#ExitError">type ExitError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#ExitError.Error">func (e *ExitError) Error() string</a></dd>
				
			
				
				<dd><a href="godoc.252.html#ExitMissingError">type ExitMissingError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#ExitMissingError.Error">func (e *ExitMissingError) Error() string</a></dd>
				
			
				
				<dd><a href="godoc.252.html#GSSAPIClient">type GSSAPIClient</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#GSSAPIServer">type GSSAPIServer</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#GSSAPIWithMICConfig">type GSSAPIWithMICConfig</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#HostKeyCallback">type HostKeyCallback</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#FixedHostKey">func FixedHostKey(key PublicKey) HostKeyCallback</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#InsecureIgnoreHostKey">func InsecureIgnoreHostKey() HostKeyCallback</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#KeyboardInteractiveChallenge">type KeyboardInteractiveChallenge</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#NewChannel">type NewChannel</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#OpenChannelError">type OpenChannelError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#OpenChannelError.Error">func (e *OpenChannelError) Error() string</a></dd>
				
			
				
				<dd><a href="godoc.252.html#Permissions">type Permissions</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#PublicKey">type PublicKey</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#NewPublicKey">func NewPublicKey(key interface{}) (PublicKey, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#ParseAuthorizedKey">func ParseAuthorizedKey(in []byte) (out PublicKey, comment string, options []string, rest []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#ParseKnownHosts">func ParseKnownHosts(in []byte) (marker string, hosts []string, pubKey PublicKey, comment string, rest []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#ParsePublicKey">func ParsePublicKey(in []byte) (out PublicKey, err error)</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#RejectionReason">type RejectionReason</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#RejectionReason.String">func (r RejectionReason) String() string</a></dd>
				
			
				
				<dd><a href="godoc.252.html#Request">type Request</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Request.Reply">func (r *Request) Reply(ok bool, payload []byte) error</a></dd>
				
			
				
				<dd><a href="godoc.252.html#ServerAuthError">type ServerAuthError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#ServerAuthError.Error">func (l ServerAuthError) Error() string</a></dd>
				
			
				
				<dd><a href="godoc.252.html#ServerConfig">type ServerConfig</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#ServerConfig.AddHostKey">func (s *ServerConfig) AddHostKey(key Signer)</a></dd>
				
			
				
				<dd><a href="godoc.252.html#ServerConn">type ServerConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#NewServerConn">func NewServerConn(c net.Conn, config *ServerConfig) (*ServerConn, &lt;-chan NewChannel, &lt;-chan *Request, error)</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#Session">type Session</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.Close">func (s *Session) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.CombinedOutput">func (s *Session) CombinedOutput(cmd string) ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.Output">func (s *Session) Output(cmd string) ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.RequestPty">func (s *Session) RequestPty(term string, h, w int, termmodes TerminalModes) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.RequestSubsystem">func (s *Session) RequestSubsystem(subsystem string) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.Run">func (s *Session) Run(cmd string) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.SendRequest">func (s *Session) SendRequest(name string, wantReply bool, payload []byte) (bool, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.Setenv">func (s *Session) Setenv(name, value string) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.Shell">func (s *Session) Shell() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.Signal">func (s *Session) Signal(sig Signal) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.Start">func (s *Session) Start(cmd string) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.StderrPipe">func (s *Session) StderrPipe() (io.Reader, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.StdinPipe">func (s *Session) StdinPipe() (io.WriteCloser, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.StdoutPipe">func (s *Session) StdoutPipe() (io.Reader, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.Wait">func (s *Session) Wait() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Session.WindowChange">func (s *Session) WindowChange(h, w int) error</a></dd>
				
			
				
				<dd><a href="godoc.252.html#Signal">type Signal</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#Signature">type Signature</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#Signer">type Signer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#NewCertSigner">func NewCertSigner(cert *Certificate, signer Signer) (Signer, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#NewSignerFromKey">func NewSignerFromKey(key interface{}) (Signer, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#NewSignerFromSigner">func NewSignerFromSigner(signer crypto.Signer) (Signer, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#ParsePrivateKey">func ParsePrivateKey(pemBytes []byte) (Signer, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#ParsePrivateKeyWithPassphrase">func ParsePrivateKeyWithPassphrase(pemBytes, passPhrase []byte) (Signer, error)</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#TerminalModes">type TerminalModes</a></dd>
				
				
			
				
				<dd><a href="godoc.252.html#Waitmsg">type Waitmsg</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Waitmsg.ExitStatus">func (w Waitmsg) ExitStatus() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Waitmsg.Lang">func (w Waitmsg) Lang() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Waitmsg.Msg">func (w Waitmsg) Msg() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Waitmsg.Signal">func (w Waitmsg) Signal() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="godoc.252.html#Waitmsg.String">func (w Waitmsg) String() string</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="godoc.252.html#example_Client_Listen">Client.Listen</a></dd>
			
			<dd><a class="exampleLink" href="godoc.252.html#example_Dial">Dial</a></dd>
			
			<dd><a class="exampleLink" href="godoc.252.html#example_NewServerConn">NewServerConn</a></dd>
			
			<dd><a class="exampleLink" href="godoc.252.html#example_PublicKeys">PublicKeys</a></dd>
			
			<dd><a class="exampleLink" href="godoc.252.html#example_RetryableAuthMethod">RetryableAuthMethod</a></dd>
			
			<dd><a class="exampleLink" href="godoc.252.html#example_Session_RequestPty">Session.RequestPty</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/buffer.go">buffer.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/certs.go">certs.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/channel.go">channel.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/cipher.go">cipher.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client.go">client.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client_auth.go">client_auth.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/common.go">common.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/connection.go">connection.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/doc.go">doc.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/handshake.go">handshake.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/kex.go">kex.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go">keys.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/mac.go">mac.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/messages.go">messages.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/mux.go">mux.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/server.go">server.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go">session.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/ssh_gss.go">ssh_gss.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/streamlocal.go">streamlocal.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/tcpip.go">tcpip.go</a>
			
				<a href="http://localhost:6161/src/golang.org/x/crypto/ssh/transport.go">transport.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>
These constants from [PROTOCOL.certkeys] represent the algorithm names
for certificate types supported by this package.
</p>

				<pre>const (
    <span id="CertAlgoRSAv01">CertAlgoRSAv01</span>      = &#34;ssh-rsa-cert-v01@openssh.com&#34;
    <span id="CertAlgoDSAv01">CertAlgoDSAv01</span>      = &#34;ssh-dss-cert-v01@openssh.com&#34;
    <span id="CertAlgoECDSA256v01">CertAlgoECDSA256v01</span> = &#34;ecdsa-sha2-nistp256-cert-v01@openssh.com&#34;
    <span id="CertAlgoECDSA384v01">CertAlgoECDSA384v01</span> = &#34;ecdsa-sha2-nistp384-cert-v01@openssh.com&#34;
    <span id="CertAlgoECDSA521v01">CertAlgoECDSA521v01</span> = &#34;ecdsa-sha2-nistp521-cert-v01@openssh.com&#34;
    <span id="CertAlgoED25519v01">CertAlgoED25519v01</span>  = &#34;ssh-ed25519-cert-v01@openssh.com&#34;
)</pre>
			
				<p>
Certificate types distinguish between host and user
certificates. The values can be set in the CertType field of
Certificate.
</p>

				<pre>const (
    <span id="UserCert">UserCert</span> = 1
    <span id="HostCert">HostCert</span> = 2
)</pre>
			
				<p>
These constants represent the algorithm names for key types supported by this
package.
</p>

				<pre>const (
    <span id="KeyAlgoRSA">KeyAlgoRSA</span>      = &#34;ssh-rsa&#34;
    <span id="KeyAlgoDSA">KeyAlgoDSA</span>      = &#34;ssh-dss&#34;
    <span id="KeyAlgoECDSA256">KeyAlgoECDSA256</span> = &#34;ecdsa-sha2-nistp256&#34;
    <span id="KeyAlgoECDSA384">KeyAlgoECDSA384</span> = &#34;ecdsa-sha2-nistp384&#34;
    <span id="KeyAlgoECDSA521">KeyAlgoECDSA521</span> = &#34;ecdsa-sha2-nistp521&#34;
    <span id="KeyAlgoED25519">KeyAlgoED25519</span>  = &#34;ssh-ed25519&#34;
)</pre>
			
				<p>
These constants represent non-default signature algorithms that are supported
as algorithm parameters to AlgorithmSigner.SignWithAlgorithm methods. See
[PROTOCOL.agent] section 4.5.1 and
<a href="https://tools.ietf.org/html/draft-ietf-curdle-rsa-sha2-10">https://tools.ietf.org/html/draft-ietf-curdle-rsa-sha2-10</a>
</p>

				<pre>const (
    <span id="SigAlgoRSA">SigAlgoRSA</span>        = &#34;ssh-rsa&#34;
    <span id="SigAlgoRSASHA2256">SigAlgoRSASHA2256</span> = &#34;rsa-sha2-256&#34;
    <span id="SigAlgoRSASHA2512">SigAlgoRSASHA2512</span> = &#34;rsa-sha2-512&#34;
)</pre>
			
				<p>
POSIX terminal mode flags as listed in RFC 4254 Section 8.
</p>

				<pre>const (
    <span id="VINTR">VINTR</span>         = 1
    <span id="VQUIT">VQUIT</span>         = 2
    <span id="VERASE">VERASE</span>        = 3
    <span id="VKILL">VKILL</span>         = 4
    <span id="VEOF">VEOF</span>          = 5
    <span id="VEOL">VEOL</span>          = 6
    <span id="VEOL2">VEOL2</span>         = 7
    <span id="VSTART">VSTART</span>        = 8
    <span id="VSTOP">VSTOP</span>         = 9
    <span id="VSUSP">VSUSP</span>         = 10
    <span id="VDSUSP">VDSUSP</span>        = 11
    <span id="VREPRINT">VREPRINT</span>      = 12
    <span id="VWERASE">VWERASE</span>       = 13
    <span id="VLNEXT">VLNEXT</span>        = 14
    <span id="VFLUSH">VFLUSH</span>        = 15
    <span id="VSWTCH">VSWTCH</span>        = 16
    <span id="VSTATUS">VSTATUS</span>       = 17
    <span id="VDISCARD">VDISCARD</span>      = 18
    <span id="IGNPAR">IGNPAR</span>        = 30
    <span id="PARMRK">PARMRK</span>        = 31
    <span id="INPCK">INPCK</span>         = 32
    <span id="ISTRIP">ISTRIP</span>        = 33
    <span id="INLCR">INLCR</span>         = 34
    <span id="IGNCR">IGNCR</span>         = 35
    <span id="ICRNL">ICRNL</span>         = 36
    <span id="IUCLC">IUCLC</span>         = 37
    <span id="IXON">IXON</span>          = 38
    <span id="IXANY">IXANY</span>         = 39
    <span id="IXOFF">IXOFF</span>         = 40
    <span id="IMAXBEL">IMAXBEL</span>       = 41
    <span id="ISIG">ISIG</span>          = 50
    <span id="ICANON">ICANON</span>        = 51
    <span id="XCASE">XCASE</span>         = 52
    <span id="ECHO">ECHO</span>          = 53
    <span id="ECHOE">ECHOE</span>         = 54
    <span id="ECHOK">ECHOK</span>         = 55
    <span id="ECHONL">ECHONL</span>        = 56
    <span id="NOFLSH">NOFLSH</span>        = 57
    <span id="TOSTOP">TOSTOP</span>        = 58
    <span id="IEXTEN">IEXTEN</span>        = 59
    <span id="ECHOCTL">ECHOCTL</span>       = 60
    <span id="ECHOKE">ECHOKE</span>        = 61
    <span id="PENDIN">PENDIN</span>        = 62
    <span id="OPOST">OPOST</span>         = 70
    <span id="OLCUC">OLCUC</span>         = 71
    <span id="ONLCR">ONLCR</span>         = 72
    <span id="OCRNL">OCRNL</span>         = 73
    <span id="ONOCR">ONOCR</span>         = 74
    <span id="ONLRET">ONLRET</span>        = 75
    <span id="CS7">CS7</span>           = 90
    <span id="CS8">CS8</span>           = 91
    <span id="PARENB">PARENB</span>        = 92
    <span id="PARODD">PARODD</span>        = 93
    <span id="TTY_OP_ISPEED">TTY_OP_ISPEED</span> = 128
    <span id="TTY_OP_OSPEED">TTY_OP_OSPEED</span> = 129
)</pre>
			
				<p>
CertTimeInfinity can be used for OpenSSHCertV01.ValidBefore to indicate that
a certificate does not expire.
</p>

				<pre>const <span id="CertTimeInfinity">CertTimeInfinity</span> = 1&lt;&lt;64 - 1</pre>
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>
ErrNoAuth is the error value returned if no
authentication method has been passed yet. This happens as a normal
part of the authentication loop, since the client first tries
&#39;none&#39; authentication to discover available methods.
It is returned in ServerAuthError.Errors from NewServerConn.
</p>

				<pre>var <span id="ErrNoAuth">ErrNoAuth</span> = <a href="godoc.550.html">errors</a>.<a href="godoc.550.html#New">New</a>(&#34;ssh: no auth passed yet&#34;)</pre>
			
		
		
			
			
			<h2 id="DiscardRequests">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/connection.go?s=2290:2330#L69">DiscardRequests</a>
				<a class="permalink" href="godoc.252.html#DiscardRequests">&#xb6;</a>
				
				
			</h2>
			<pre>func DiscardRequests(in &lt;-chan *<a href="godoc.252.html#Request">Request</a>)</pre>
			<p>
DiscardRequests consumes and rejects all requests from the
passed-in channel.
</p>

			
			

		
			
			
			<h2 id="FingerprintLegacyMD5">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=27614:27664#L1072">FingerprintLegacyMD5</a>
				<a class="permalink" href="godoc.252.html#FingerprintLegacyMD5">&#xb6;</a>
				
				
			</h2>
			<pre>func FingerprintLegacyMD5(pubKey <a href="godoc.252.html#PublicKey">PublicKey</a>) <a href="godoc.4.html#string">string</a></pre>
			<p>
FingerprintLegacyMD5 returns the user presentation of the key&#39;s
fingerprint as described by RFC 4716 section 4.
</p>

			
			

		
			
			
			<h2 id="FingerprintSHA256">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=28149:28196#L1086">FingerprintSHA256</a>
				<a class="permalink" href="godoc.252.html#FingerprintSHA256">&#xb6;</a>
				
				
			</h2>
			<pre>func FingerprintSHA256(pubKey <a href="godoc.252.html#PublicKey">PublicKey</a>) <a href="godoc.4.html#string">string</a></pre>
			<p>
FingerprintSHA256 returns the user presentation of the key&#39;s
fingerprint as unpadded base64 encoded sha256 hash.
This format was introduced from OpenSSH 6.8.
<a href="https://www.openssh.com/txt/release-6.8">https://www.openssh.com/txt/release-6.8</a>
<a href="https://tools.ietf.org/html/rfc4648#section-3.2">https://tools.ietf.org/html/rfc4648#section-3.2</a> (unpadded base64 encoding)
</p>

			
			

		
			
			
			<h2 id="Marshal">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/messages.go?s=11101:11137#L487">Marshal</a>
				<a class="permalink" href="godoc.252.html#Marshal">&#xb6;</a>
				
				
			</h2>
			<pre>func Marshal(msg interface{}) []<a href="godoc.4.html#byte">byte</a></pre>
			<p>
Marshal serializes the message in msg to SSH wire format.  The msg
argument should be a struct or pointer to struct. If the first
member has the &#34;sshtype&#34; tag set to a number in decimal, that
number is prepended to the result. If the last of member has the
&#34;ssh&#34; tag set to &#34;rest&#34;, its contents are appended to the output.
</p>

			
			

		
			
			
			<h2 id="MarshalAuthorizedKey">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=7194:7241#L262">MarshalAuthorizedKey</a>
				<a class="permalink" href="godoc.252.html#MarshalAuthorizedKey">&#xb6;</a>
				
				
			</h2>
			<pre>func MarshalAuthorizedKey(key <a href="godoc.252.html#PublicKey">PublicKey</a>) []<a href="godoc.4.html#byte">byte</a></pre>
			<p>
MarshalAuthorizedKey serializes key for inclusion in an OpenSSH
authorized_keys file. The return value ends with newline.
</p>

			
			

		
			
			
			<h2 id="ParseDSAPrivateKey">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=24477:24537#L928">ParseDSAPrivateKey</a>
				<a class="permalink" href="godoc.252.html#ParseDSAPrivateKey">&#xb6;</a>
				
				
			</h2>
			<pre>func ParseDSAPrivateKey(der []<a href="godoc.4.html#byte">byte</a>) (*<a href="godoc.192.html">dsa</a>.<a href="godoc.192.html#PrivateKey">PrivateKey</a>, <a href="godoc.4.html#error">error</a>)</pre>
			<p>
ParseDSAPrivateKey returns a DSA private key from its ASN.1 DER encoding, as
specified by the OpenSSL DSA man page.
</p>

			
			

		
			
			
			<h2 id="ParseRawPrivateKey">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=22509:22570#L862">ParseRawPrivateKey</a>
				<a class="permalink" href="godoc.252.html#ParseRawPrivateKey">&#xb6;</a>
				
				
			</h2>
			<pre>func ParseRawPrivateKey(pemBytes []<a href="godoc.4.html#byte">byte</a>) (interface{}, <a href="godoc.4.html#error">error</a>)</pre>
			<p>
ParseRawPrivateKey returns a private key from a PEM encoded private key. It
supports RSA (PKCS#1), PKCS#8, DSA (OpenSSL), and ECDSA private keys.
</p>

			
			

		
			
			
			<h2 id="ParseRawPrivateKeyWithPassphrase">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=23464:23551#L892">ParseRawPrivateKeyWithPassphrase</a>
				<a class="permalink" href="godoc.252.html#ParseRawPrivateKeyWithPassphrase">&#xb6;</a>
				
				
			</h2>
			<pre>func ParseRawPrivateKeyWithPassphrase(pemBytes, passPhrase []<a href="godoc.4.html#byte">byte</a>) (interface{}, <a href="godoc.4.html#error">error</a>)</pre>
			<p>
ParseRawPrivateKeyWithPassphrase returns a private key decrypted with
passphrase from a PEM encoded private key. If wrong passphrase, return
x509.IncorrectPasswordError.
</p>

			
			

		
			
			
			<h2 id="Unmarshal">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/messages.go?s=8049:8099#L364">Unmarshal</a>
				<a class="permalink" href="godoc.252.html#Unmarshal">&#xb6;</a>
				
				
			</h2>
			<pre>func Unmarshal(data []<a href="godoc.4.html#byte">byte</a>, out interface{}) <a href="godoc.4.html#error">error</a></pre>
			<p>
Unmarshal parses data in SSH wire format into a structure. The out
argument should be a pointer to struct. If the first member of the
struct has the &#34;sshtype&#34; tag set to a &#39;|&#39;-separated set of numbers
in decimal, the packet must start with one of those numbers. In
case of error, Unmarshal returns a ParseError or
UnexpectedMessageError.
</p>

			
			

		
		
			
			
			<h2 id="AlgorithmSigner">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=8588:9049#L306">AlgorithmSigner</a>
				<a class="permalink" href="godoc.252.html#AlgorithmSigner">&#xb6;</a>
				
				
			</h2>
			<p>
A AlgorithmSigner is a Signer that also supports specifying a specific
algorithm to use for signing.
</p>

			<pre>type AlgorithmSigner interface {
    <a href="godoc.252.html#Signer">Signer</a>

    <span class="comment">// SignWithAlgorithm is like Signer.Sign, but allows specification of a</span>
    <span class="comment">// non-default signing algorithm. See the SigAlgo* constants in this</span>
    <span class="comment">// package for signature algorithms supported by this package. Callers may</span>
    <span class="comment">// pass an empty string for the algorithm in which case the AlgorithmSigner</span>
    <span class="comment">// will use its default algorithm.</span>
    SignWithAlgorithm(rand <a href="godoc.585.html">io</a>.<a href="godoc.585.html#Reader">Reader</a>, data []<a href="godoc.4.html#byte">byte</a>, algorithm <a href="godoc.4.html#string">string</a>) (*<a href="godoc.252.html#Signature">Signature</a>, <a href="godoc.4.html#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="AuthMethod">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client_auth.go?s=1975:2456#L78">AuthMethod</a>
				<a class="permalink" href="godoc.252.html#AuthMethod">&#xb6;</a>
				
				
			</h2>
			<p>
An AuthMethod represents an instance of an RFC 4252 authentication method.
</p>

			<pre>type AuthMethod interface {
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="GSSAPIWithMICAuthMethod">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client_auth.go?s=14904:14985#L521">GSSAPIWithMICAuthMethod</a>
					<a class="permalink" href="godoc.252.html#GSSAPIWithMICAuthMethod">&#xb6;</a>
					
					
				</h3>
				<pre>func GSSAPIWithMICAuthMethod(gssAPIClient <a href="godoc.252.html#GSSAPIClient">GSSAPIClient</a>, target <a href="godoc.4.html#string">string</a>) <a href="godoc.252.html#AuthMethod">AuthMethod</a></pre>
				<p>
GSSAPIWithMICAuthMethod is an AuthMethod with &#34;gssapi-with-mic&#34; authentication.
See RFC 4462 section 3
gssAPIClient is implementation of the GSSAPIClient interface, see the definition of the interface for details.
target is the server host you want to log in to.
</p>

				
				
			
				
				<h3 id="KeyboardInteractive">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client_auth.go?s=10486:10561#L378">KeyboardInteractive</a>
					<a class="permalink" href="godoc.252.html#KeyboardInteractive">&#xb6;</a>
					
					
				</h3>
				<pre>func KeyboardInteractive(challenge <a href="godoc.252.html#KeyboardInteractiveChallenge">KeyboardInteractiveChallenge</a>) <a href="godoc.252.html#AuthMethod">AuthMethod</a></pre>
				<p>
KeyboardInteractive returns an AuthMethod using a prompt/response
sequence controlled by the server.
</p>

				
				
			
				
				<h3 id="Password">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client_auth.go?s=3935:3974#L148">Password</a>
					<a class="permalink" href="godoc.252.html#Password">&#xb6;</a>
					
					
				</h3>
				<pre>func Password(secret <a href="godoc.4.html#string">string</a>) <a href="godoc.252.html#AuthMethod">AuthMethod</a></pre>
				<p>
Password returns an AuthMethod using the given password.
</p>

				
				
			
				
				<h3 id="PasswordCallback">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client_auth.go?s=4143:4217#L154">PasswordCallback</a>
					<a class="permalink" href="godoc.252.html#PasswordCallback">&#xb6;</a>
					
					
				</h3>
				<pre>func PasswordCallback(prompt func() (secret <a href="godoc.4.html#string">string</a>, err <a href="godoc.4.html#error">error</a>)) <a href="godoc.252.html#AuthMethod">AuthMethod</a></pre>
				<p>
PasswordCallback returns an AuthMethod that uses a callback for
fetching a password.
</p>

				
				
			
				
				<h3 id="PublicKeys">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client_auth.go?s=8163:8208#L307">PublicKeys</a>
					<a class="permalink" href="godoc.252.html#PublicKeys">&#xb6;</a>
					
					
				</h3>
				<pre>func PublicKeys(signers ...<a href="godoc.252.html#Signer">Signer</a>) <a href="godoc.252.html#AuthMethod">AuthMethod</a></pre>
				<p>
PublicKeys returns an AuthMethod that uses the given key
pairs.
</p>

				<div id="example_PublicKeys" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
var hostKey ssh.PublicKey
<span class="comment">// A public key may be used to authenticate against the remote</span>
<span class="comment">// server by using an unencrypted PEM-encoded private key file.</span>
<span class="comment">//</span>
<span class="comment">// If you have an encrypted private key, the crypto/x509 package</span>
<span class="comment">// can be used to decrypt it.</span>
key, err := ioutil.ReadFile(&#34;/home/user/.ssh/id_rsa&#34;)
if err != nil {
    log.Fatalf(&#34;unable to read private key: %v&#34;, err)
}

<span class="comment">// Create the Signer for this private key.</span>
signer, err := ssh.ParsePrivateKey(key)
if err != nil {
    log.Fatalf(&#34;unable to parse private key: %v&#34;, err)
}

config := &amp;ssh.ClientConfig{
    User: &#34;user&#34;,
    Auth: []ssh.AuthMethod{
        <span class="comment">// Use the PublicKeys method for remote authentication.</span>
        ssh.PublicKeys(signer),
    },
    HostKeyCallback: ssh.FixedHostKey(hostKey),
}

<span class="comment">// Connect to the remote server and perform the SSH handshake.</span>
client, err := ssh.Dial(&#34;tcp&#34;, &#34;host.com:22&#34;, config)
if err != nil {
    log.Fatalf(&#34;unable to connect: %v&#34;, err)
}
defer client.Close()
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="PublicKeysCallback">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client_auth.go?s=8397:8480#L313">PublicKeysCallback</a>
					<a class="permalink" href="godoc.252.html#PublicKeysCallback">&#xb6;</a>
					
					
				</h3>
				<pre>func PublicKeysCallback(getSigners func() (signers []<a href="godoc.252.html#Signer">Signer</a>, err <a href="godoc.4.html#error">error</a>)) <a href="godoc.252.html#AuthMethod">AuthMethod</a></pre>
				<p>
PublicKeysCallback returns an AuthMethod that runs the given
function to obtain a list of key pairs.
</p>

				
				
			
				
				<h3 id="RetryableAuthMethod">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client_auth.go?s=14490:14556#L513">RetryableAuthMethod</a>
					<a class="permalink" href="godoc.252.html#RetryableAuthMethod">&#xb6;</a>
					
					
				</h3>
				<pre>func RetryableAuthMethod(auth <a href="godoc.252.html#AuthMethod">AuthMethod</a>, maxTries <a href="godoc.4.html#int">int</a>) <a href="godoc.252.html#AuthMethod">AuthMethod</a></pre>
				<p>
RetryableAuthMethod is a decorator for other auth methods enabling them to
be retried up to maxTries before considering that AuthMethod itself failed.
If maxTries is &lt;= 0, will retry indefinitely
</p>
<p>
This is useful for interactive clients using challenge/response type
authentication (e.g. Keyboard-Interactive, Password, etc) where the user
could mistype their response resulting in the server issuing a
SSH_MSG_USERAUTH_FAILURE (rfc4252 #8 [password] and rfc4256 #3.4
[keyboard-interactive]); Without this decorator, the non-retryable
AuthMethod would be removed from future consideration, and never tried again
(and so the user would never be able to retry their entry).
</p>

				<div id="example_RetryableAuthMethod" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
user := &#34;testuser&#34;
NumberOfPrompts := 3

<span class="comment">// Normally this would be a callback that prompts the user to answer the</span>
<span class="comment">// provided questions</span>
Cb := func(user, instruction string, questions []string, echos []bool) (answers []string, err error) {
    return []string{&#34;answer1&#34;, &#34;answer2&#34;}, nil
}

config := &amp;ClientConfig{
    HostKeyCallback: InsecureIgnoreHostKey(),
    User:            user,
    Auth: []AuthMethod{
        RetryableAuthMethod(KeyboardInteractiveChallenge(Cb), NumberOfPrompts),
    },
}

host := &#34;mysshserver&#34;
netConn, err := net.Dial(&#34;tcp&#34;, host)
if err != nil {
    log.Fatal(err)
}

sshConn, _, _, err := NewClientConn(netConn, host, config)
if err != nil {
    log.Fatal(err)
}
_ = sshConn
</pre>
			
		
	</div>
</div>

				
			

			
		
			
			
			<h2 id="BannerCallback">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client.go?s=5618:5664#L183">BannerCallback</a>
				<a class="permalink" href="godoc.252.html#BannerCallback">&#xb6;</a>
				
				
			</h2>
			<p>
BannerCallback is the function type used for treat the banner sent by
the server. A BannerCallback receives the message sent by the remote server.
</p>

			<pre>type BannerCallback func(message <a href="godoc.4.html#string">string</a>) <a href="godoc.4.html#error">error</a></pre>

			

			

			
			
			

			
				
				<h3 id="BannerDisplayStderr">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client.go?s=8387:8428#L262">BannerDisplayStderr</a>
					<a class="permalink" href="godoc.252.html#BannerDisplayStderr">&#xb6;</a>
					
					
				</h3>
				<pre>func BannerDisplayStderr() <a href="godoc.252.html#BannerCallback">BannerCallback</a></pre>
				<p>
BannerDisplayStderr returns a function that can be used for
ClientConfig.BannerCallback to display banners on os.Stderr.
</p>

				
				
			

			
		
			
			
			<h2 id="CertChecker">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/certs.go?s=6855:8660#L254">CertChecker</a>
				<a class="permalink" href="godoc.252.html#CertChecker">&#xb6;</a>
				
				
			</h2>
			<p>
CertChecker does the work of verifying a certificate. Its methods
can be plugged into ClientConfig.HostKeyCallback and
ServerConfig.PublicKeyCallback. For the CertChecker to work,
minimally, the IsAuthority callback should be set.
</p>

			<pre>type CertChecker struct {
<span id="CertChecker.SupportedCriticalOptions"></span>    <span class="comment">// SupportedCriticalOptions lists the CriticalOptions that the</span>
    <span class="comment">// server application layer understands. These are only used</span>
    <span class="comment">// for user certificates.</span>
    SupportedCriticalOptions []<a href="godoc.4.html#string">string</a>

<span id="CertChecker.IsUserAuthority"></span>    <span class="comment">// IsUserAuthority should return true if the key is recognized as an</span>
    <span class="comment">// authority for the given user certificate. This allows for</span>
    <span class="comment">// certificates to be signed by other certificates. This must be set</span>
    <span class="comment">// if this CertChecker will be checking user certificates.</span>
    IsUserAuthority func(auth <a href="godoc.252.html#PublicKey">PublicKey</a>) <a href="godoc.4.html#bool">bool</a>

<span id="CertChecker.IsHostAuthority"></span>    <span class="comment">// IsHostAuthority should report whether the key is recognized as</span>
    <span class="comment">// an authority for this host. This allows for certificates to be</span>
    <span class="comment">// signed by other keys, and for those other keys to only be valid</span>
    <span class="comment">// signers for particular hostnames. This must be set if this</span>
    <span class="comment">// CertChecker will be checking host certificates.</span>
    IsHostAuthority func(auth <a href="godoc.252.html#PublicKey">PublicKey</a>, address <a href="godoc.4.html#string">string</a>) <a href="godoc.4.html#bool">bool</a>

<span id="CertChecker.Clock"></span>    <span class="comment">// Clock is used for verifying time stamps. If nil, time.Now</span>
    <span class="comment">// is used.</span>
    Clock func() <a href="godoc.66.html">time</a>.<a href="godoc.66.html#Time">Time</a>

<span id="CertChecker.UserKeyFallback"></span>    <span class="comment">// UserKeyFallback is called when CertChecker.Authenticate encounters a</span>
    <span class="comment">// public key that is not a certificate. It must implement validation</span>
    <span class="comment">// of user keys or else, if nil, all such keys are rejected.</span>
    UserKeyFallback func(conn <a href="godoc.252.html#ConnMetadata">ConnMetadata</a>, key <a href="godoc.252.html#PublicKey">PublicKey</a>) (*<a href="godoc.252.html#Permissions">Permissions</a>, <a href="godoc.4.html#error">error</a>)

<span id="CertChecker.HostKeyFallback"></span>    <span class="comment">// HostKeyFallback is called when CertChecker.CheckHostKey encounters a</span>
    <span class="comment">// public key that is not a certificate. It must implement host key</span>
    <span class="comment">// validation or else, if nil, all such keys are rejected.</span>
    HostKeyFallback <a href="godoc.252.html#HostKeyCallback">HostKeyCallback</a>

<span id="CertChecker.IsRevoked"></span>    <span class="comment">// IsRevoked is called for each certificate so that revocation checking</span>
    <span class="comment">// can be implemented. It should return true if the given certificate</span>
    <span class="comment">// is revoked and false otherwise. If nil, no certificates are</span>
    <span class="comment">// considered to have been revoked.</span>
    IsRevoked func(cert *<a href="godoc.252.html#Certificate">Certificate</a>) <a href="godoc.4.html#bool">bool</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="CertChecker.Authenticate">func (*CertChecker) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/certs.go?s=9609:9702#L322">Authenticate</a>
					<a class="permalink" href="godoc.252.html#CertChecker.Authenticate">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#CertChecker">CertChecker</a>) Authenticate(conn <a href="godoc.252.html#ConnMetadata">ConnMetadata</a>, pubKey <a href="godoc.252.html#PublicKey">PublicKey</a>) (*<a href="godoc.252.html#Permissions">Permissions</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
Authenticate checks a user certificate. Authenticate can be used as
a value for ServerConfig.PublicKeyCallback.
</p>

				
				
				
			
				
				<h3 id="CertChecker.CheckCert">func (*CertChecker) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/certs.go?s=10350:10424#L347">CheckCert</a>
					<a class="permalink" href="godoc.252.html#CertChecker.CheckCert">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#CertChecker">CertChecker</a>) CheckCert(principal <a href="godoc.4.html#string">string</a>, cert *<a href="godoc.252.html#Certificate">Certificate</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
CheckCert checks CriticalOptions, ValidPrincipals, revocation, timestamp and
the signature of the certificate.
</p>

				
				
				
			
				
				<h3 id="CertChecker.CheckHostKey">func (*CertChecker) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/certs.go?s=8774:8859#L296">CheckHostKey</a>
					<a class="permalink" href="godoc.252.html#CertChecker.CheckHostKey">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#CertChecker">CertChecker</a>) CheckHostKey(addr <a href="godoc.4.html#string">string</a>, remote <a href="godoc.14.html">net</a>.<a href="godoc.14.html#Addr">Addr</a>, key <a href="godoc.252.html#PublicKey">PublicKey</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
CheckHostKey checks a host key certificate. This method can be
plugged into ClientConfig.HostKeyCallback.
</p>

				
				
				
			
		
			
			
			<h2 id="Certificate">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/certs.go?s=1381:1688#L40">Certificate</a>
				<a class="permalink" href="godoc.252.html#Certificate">&#xb6;</a>
				
				
			</h2>
			<p>
An Certificate represents an OpenSSH certificate as defined in
[PROTOCOL.certkeys]?rev=1.8. The Certificate type implements the
PublicKey interface, so it can be unmarshaled using
ParsePublicKey.
</p>

			<pre>type Certificate struct {
<span id="Certificate.Nonce"></span>    Nonce           []<a href="godoc.4.html#byte">byte</a>
<span id="Certificate.Key"></span>    Key             <a href="godoc.252.html#PublicKey">PublicKey</a>
<span id="Certificate.Serial"></span>    Serial          <a href="godoc.4.html#uint64">uint64</a>
<span id="Certificate.CertType"></span>    CertType        <a href="godoc.4.html#uint32">uint32</a>
<span id="Certificate.KeyId"></span>    KeyId           <a href="godoc.4.html#string">string</a>
<span id="Certificate.ValidPrincipals"></span>    ValidPrincipals []<a href="godoc.4.html#string">string</a>
<span id="Certificate.ValidAfter"></span>    ValidAfter      <a href="godoc.4.html#uint64">uint64</a>
<span id="Certificate.ValidBefore"></span>    ValidBefore     <a href="godoc.4.html#uint64">uint64</a>
    <a href="godoc.252.html#Permissions">Permissions</a>
<span id="Certificate.Reserved"></span>    Reserved     []<a href="godoc.4.html#byte">byte</a>
<span id="Certificate.SignatureKey"></span>    SignatureKey <a href="godoc.252.html#PublicKey">PublicKey</a>
<span id="Certificate.Signature"></span>    Signature    *<a href="godoc.252.html#Signature">Signature</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Certificate.Marshal">func (*Certificate) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/certs.go?s=13184:13222#L451">Marshal</a>
					<a class="permalink" href="godoc.252.html#Certificate.Marshal">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#Certificate">Certificate</a>) Marshal() []<a href="godoc.4.html#byte">byte</a></pre>
				<p>
Marshal serializes c into OpenSSH&#39;s wire format. It is part of the
PublicKey interface.
</p>

				
				
				
			
				
				<h3 id="Certificate.SignCert">func (*Certificate) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/certs.go?s=12013:12083#L406">SignCert</a>
					<a class="permalink" href="godoc.252.html#Certificate.SignCert">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#Certificate">Certificate</a>) SignCert(rand <a href="godoc.585.html">io</a>.<a href="godoc.585.html#Reader">Reader</a>, authority <a href="godoc.252.html#Signer">Signer</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
SignCert sets c.SignatureKey to the authority&#39;s public key and stores a
Signature, by authority, in the certificate.
</p>

				
				
				
			
				
				<h3 id="Certificate.Type">func (*Certificate) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/certs.go?s=14181:14216#L483">Type</a>
					<a class="permalink" href="godoc.252.html#Certificate.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#Certificate">Certificate</a>) Type() <a href="godoc.4.html#string">string</a></pre>
				<p>
Type returns the key name. It is part of the PublicKey interface.
</p>

				
				
				
			
				
				<h3 id="Certificate.Verify">func (*Certificate) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/certs.go?s=14449:14512#L493">Verify</a>
					<a class="permalink" href="godoc.252.html#Certificate.Verify">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#Certificate">Certificate</a>) Verify(data []<a href="godoc.4.html#byte">byte</a>, sig *<a href="godoc.252.html#Signature">Signature</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
Verify verifies a signature against the certificate&#39;s public
key. It is part of the PublicKey interface.
</p>

				
				
				
			
		
			
			
			<h2 id="Channel">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/channel.go?s=1492:2639#L39">Channel</a>
				<a class="permalink" href="godoc.252.html#Channel">&#xb6;</a>
				
				
			</h2>
			<p>
A Channel is an ordered, reliable, flow-controlled, duplex stream
that is multiplexed over an SSH connection.
</p>

			<pre>type Channel interface {
    <span class="comment">// Read reads up to len(data) bytes from the channel.</span>
    Read(data []<a href="godoc.4.html#byte">byte</a>) (<a href="godoc.4.html#int">int</a>, <a href="godoc.4.html#error">error</a>)

    <span class="comment">// Write writes len(data) bytes to the channel.</span>
    Write(data []<a href="godoc.4.html#byte">byte</a>) (<a href="godoc.4.html#int">int</a>, <a href="godoc.4.html#error">error</a>)

    <span class="comment">// Close signals end of channel use. No data may be sent after this</span>
    <span class="comment">// call.</span>
    Close() <a href="godoc.4.html#error">error</a>

    <span class="comment">// CloseWrite signals the end of sending in-band</span>
    <span class="comment">// data. Requests may still be sent, and the other side may</span>
    <span class="comment">// still send data</span>
    CloseWrite() <a href="godoc.4.html#error">error</a>

    <span class="comment">// SendRequest sends a channel request.  If wantReply is true,</span>
    <span class="comment">// it will wait for a reply and return the result as a</span>
    <span class="comment">// boolean, otherwise the return value will be false. Channel</span>
    <span class="comment">// requests are out-of-band messages so they may be sent even</span>
    <span class="comment">// if the data stream is closed or blocked by flow control.</span>
    <span class="comment">// If the channel is closed before a reply is returned, io.EOF</span>
    <span class="comment">// is returned.</span>
    SendRequest(name <a href="godoc.4.html#string">string</a>, wantReply <a href="godoc.4.html#bool">bool</a>, payload []<a href="godoc.4.html#byte">byte</a>) (<a href="godoc.4.html#bool">bool</a>, <a href="godoc.4.html#error">error</a>)

    <span class="comment">// Stderr returns an io.ReadWriter that writes to this channel</span>
    <span class="comment">// with the extended data type set to stderr. Stderr may</span>
    <span class="comment">// safely be read and written from a different goroutine than</span>
    <span class="comment">// Read and Write respectively.</span>
    Stderr() <a href="godoc.585.html">io</a>.<a href="godoc.585.html#ReadWriter">ReadWriter</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Client">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client.go?s=379:635#L9">Client</a>
				<a class="permalink" href="godoc.252.html#Client">&#xb6;</a>
				
				
			</h2>
			<p>
Client implements a traditional SSH client that supports shells,
subprocesses, TCP port/streamlocal forwarding and tunneled dialing.
</p>

			<pre>type Client struct {
    <a href="godoc.252.html#Conn">Conn</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="Dial">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client.go?s=4760:4830#L162">Dial</a>
					<a class="permalink" href="godoc.252.html#Dial">&#xb6;</a>
					
					
				</h3>
				<pre>func Dial(network, addr <a href="godoc.4.html#string">string</a>, config *<a href="godoc.252.html#ClientConfig">ClientConfig</a>) (*<a href="godoc.252.html#Client">Client</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
Dial starts a client connection to the given SSH server. It is a
convenience function that connects to the given network address,
initiates the SSH handshake, and then sets up a Client.  For access
to incoming channels and requests, use net.Dial with NewClientConn
instead.
</p>

				<div id="example_Dial" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
var hostKey ssh.PublicKey
<span class="comment">// An SSH client is represented with a ClientConn.</span>
<span class="comment">//</span>
<span class="comment">// To authenticate with the remote server you must pass at least one</span>
<span class="comment">// implementation of AuthMethod via the Auth field in ClientConfig,</span>
<span class="comment">// and provide a HostKeyCallback.</span>
config := &amp;ssh.ClientConfig{
    User: &#34;username&#34;,
    Auth: []ssh.AuthMethod{
        ssh.Password(&#34;yourpassword&#34;),
    },
    HostKeyCallback: ssh.FixedHostKey(hostKey),
}
client, err := ssh.Dial(&#34;tcp&#34;, &#34;yourserver.com:22&#34;, config)
if err != nil {
    log.Fatal(&#34;Failed to dial: &#34;, err)
}

<span class="comment">// Each ClientConn can support multiple interactive sessions,</span>
<span class="comment">// represented by a Session.</span>
session, err := client.NewSession()
if err != nil {
    log.Fatal(&#34;Failed to create session: &#34;, err)
}
defer session.Close()

<span class="comment">// Once a Session is created, you can execute a single command on</span>
<span class="comment">// the remote side using the Run method.</span>
var b bytes.Buffer
session.Stdout = &amp;b
if err := session.Run(&#34;/usr/bin/whoami&#34;); err != nil {
    log.Fatal(&#34;Failed to run: &#34; + err.Error())
}
fmt.Println(b.String())
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="NewClient">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client.go?s=1303:1380#L43">NewClient</a>
					<a class="permalink" href="godoc.252.html#NewClient">&#xb6;</a>
					
					
				</h3>
				<pre>func NewClient(c <a href="godoc.252.html#Conn">Conn</a>, chans &lt;-chan <a href="godoc.252.html#NewChannel">NewChannel</a>, reqs &lt;-chan *<a href="godoc.252.html#Request">Request</a>) *<a href="godoc.252.html#Client">Client</a></pre>
				<p>
NewClient creates a Client on top of the given connection.
</p>

				
				
			

			
				
				<h3 id="Client.Dial">func (*Client) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/tcpip.go?s=8926:8981#L327">Dial</a>
					<a class="permalink" href="godoc.252.html#Client.Dial">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#Client">Client</a>) Dial(n, addr <a href="godoc.4.html#string">string</a>) (<a href="godoc.14.html">net</a>.<a href="godoc.14.html#Conn">Conn</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
Dial initiates a connection to the addr from the remote host.
The resulting connection has a zero LocalAddr() and RemoteAddr().
</p>

				
				
				
			
				
				<h3 id="Client.DialTCP">func (*Client) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/tcpip.go?s=10137:10216#L379">DialTCP</a>
					<a class="permalink" href="godoc.252.html#Client.DialTCP">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#Client">Client</a>) DialTCP(n <a href="godoc.4.html#string">string</a>, laddr, raddr *<a href="godoc.14.html">net</a>.<a href="godoc.14.html#TCPAddr">TCPAddr</a>) (<a href="godoc.14.html">net</a>.<a href="godoc.14.html#Conn">Conn</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
DialTCP connects to the remote address raddr on the network net,
which must be &#34;tcp&#34;, &#34;tcp4&#34;, or &#34;tcp6&#34;.  If laddr is not nil, it is used
as the local address for the connection.
</p>

				
				
				
			
				
				<h3 id="Client.HandleChannelOpen">func (*Client) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client.go?s=848:920#L22">HandleChannelOpen</a>
					<a class="permalink" href="godoc.252.html#Client.HandleChannelOpen">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#Client">Client</a>) HandleChannelOpen(channelType <a href="godoc.4.html#string">string</a>) &lt;-chan <a href="godoc.252.html#NewChannel">NewChannel</a></pre>
				<p>
HandleChannelOpen returns a channel on which NewChannel requests
for the given type are sent. If the type already is being handled,
nil is returned. The channel is closed when the connection is closed.
</p>

				
				
				
			
				
				<h3 id="Client.Listen">func (*Client) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/tcpip.go?s=540:601#L14">Listen</a>
					<a class="permalink" href="godoc.252.html#Client.Listen">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#Client">Client</a>) Listen(n, addr <a href="godoc.4.html#string">string</a>) (<a href="godoc.14.html">net</a>.<a href="godoc.14.html#Listener">Listener</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
Listen requests the remote peer open a listening socket on
addr. Incoming connections will be available by calling Accept on
the returned net.Listener. The listener must be serviced, or the
SSH connection may hang.
N must be &#34;tcp&#34;, &#34;tcp4&#34;, &#34;tcp6&#34;, or &#34;unix&#34;.
</p>

				
				<div id="example_Client_Listen" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
var hostKey ssh.PublicKey
config := &amp;ssh.ClientConfig{
    User: &#34;username&#34;,
    Auth: []ssh.AuthMethod{
        ssh.Password(&#34;password&#34;),
    },
    HostKeyCallback: ssh.FixedHostKey(hostKey),
}
<span class="comment">// Dial your ssh server.</span>
conn, err := ssh.Dial(&#34;tcp&#34;, &#34;localhost:22&#34;, config)
if err != nil {
    log.Fatal(&#34;unable to connect: &#34;, err)
}
defer conn.Close()

<span class="comment">// Request the remote side to open port 8080 on all interfaces.</span>
l, err := conn.Listen(&#34;tcp&#34;, &#34;0.0.0.0:8080&#34;)
if err != nil {
    log.Fatal(&#34;unable to register tcp forward: &#34;, err)
}
defer l.Close()

<span class="comment">// Serve HTTP with your SSH server acting as a reverse proxy.</span>
http.Serve(l, http.HandlerFunc(func(resp http.ResponseWriter, req *http.Request) {
    fmt.Fprintf(resp, &#34;Hello world!\n&#34;)
}))
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Client.ListenTCP">func (*Client) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/tcpip.go?s=3017:3085#L94">ListenTCP</a>
					<a class="permalink" href="godoc.252.html#Client.ListenTCP">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#Client">Client</a>) ListenTCP(laddr *<a href="godoc.14.html">net</a>.<a href="godoc.14.html#TCPAddr">TCPAddr</a>) (<a href="godoc.14.html">net</a>.<a href="godoc.14.html#Listener">Listener</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
ListenTCP requests the remote peer open a listening socket
on laddr. Incoming connections will be available by calling
Accept on the returned net.Listener.
</p>

				
				
				
			
				
				<h3 id="Client.ListenUnix">func (*Client) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/streamlocal.go?s=979:1047#L24">ListenUnix</a>
					<a class="permalink" href="godoc.252.html#Client.ListenUnix">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#Client">Client</a>) ListenUnix(socketPath <a href="godoc.4.html#string">string</a>) (<a href="godoc.14.html">net</a>.<a href="godoc.14.html#Listener">Listener</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
ListenUnix is similar to ListenTCP but uses a Unix domain socket.
</p>

				
				
				
			
				
				<h3 id="Client.NewSession">func (*Client) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client.go?s=3617:3664#L119">NewSession</a>
					<a class="permalink" href="godoc.252.html#Client.NewSession">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#Client">Client</a>) NewSession() (*<a href="godoc.252.html#Session">Session</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
NewSession opens a new Session for this client. (A session is a remote
execution of a program.)
</p>

				
				
				
			
		
			
			
			<h2 id="ClientConfig">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client.go?s=5797:7422#L187">ClientConfig</a>
				<a class="permalink" href="godoc.252.html#ClientConfig">&#xb6;</a>
				
				
			</h2>
			<p>
A ClientConfig structure is used to configure a Client. It must not be
modified after having been passed to an SSH function.
</p>

			<pre>type ClientConfig struct {
    <span class="comment">// Config contains configuration that is shared between clients and</span>
    <span class="comment">// servers.</span>
    <a href="godoc.252.html#Config">Config</a>

<span id="ClientConfig.User"></span>    <span class="comment">// User contains the username to authenticate as.</span>
    User <a href="godoc.4.html#string">string</a>

<span id="ClientConfig.Auth"></span>    <span class="comment">// Auth contains possible authentication methods to use with the</span>
    <span class="comment">// server. Only the first instance of a particular RFC 4252 method will</span>
    <span class="comment">// be used during authentication.</span>
    Auth []<a href="godoc.252.html#AuthMethod">AuthMethod</a>

<span id="ClientConfig.HostKeyCallback"></span>    <span class="comment">// HostKeyCallback is called during the cryptographic</span>
    <span class="comment">// handshake to validate the server&#39;s host key. The client</span>
    <span class="comment">// configuration must supply this callback for the connection</span>
    <span class="comment">// to succeed. The functions InsecureIgnoreHostKey or</span>
    <span class="comment">// FixedHostKey can be used for simplistic host key checks.</span>
    HostKeyCallback <a href="godoc.252.html#HostKeyCallback">HostKeyCallback</a>

<span id="ClientConfig.BannerCallback"></span>    <span class="comment">// BannerCallback is called during the SSH dance to display a custom</span>
    <span class="comment">// server&#39;s message. The client configuration can supply this callback to</span>
    <span class="comment">// handle it as wished. The function BannerDisplayStderr can be used for</span>
    <span class="comment">// simplistic display on Stderr.</span>
    BannerCallback <a href="godoc.252.html#BannerCallback">BannerCallback</a>

<span id="ClientConfig.ClientVersion"></span>    <span class="comment">// ClientVersion contains the version identification string that will</span>
    <span class="comment">// be used for the connection. If empty, a reasonable default is used.</span>
    ClientVersion <a href="godoc.4.html#string">string</a>

<span id="ClientConfig.HostKeyAlgorithms"></span>    <span class="comment">// HostKeyAlgorithms lists the key types that the client will</span>
    <span class="comment">// accept from the server as host key, in order of</span>
    <span class="comment">// preference. If empty, a reasonable default is used. Any</span>
    <span class="comment">// string returned from PublicKey.Type method may be used, or</span>
    <span class="comment">// any of the CertAlgoXxxx and KeyAlgoXxxx constants.</span>
    HostKeyAlgorithms []<a href="godoc.4.html#string">string</a>

<span id="ClientConfig.Timeout"></span>    <span class="comment">// Timeout is the maximum amount of time for the TCP connection to establish.</span>
    <span class="comment">//</span>
    <span class="comment">// A Timeout of zero means no timeout.</span>
    Timeout <a href="godoc.66.html">time</a>.<a href="godoc.66.html#Duration">Duration</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Config">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/common.go?s=6324:7064#L203">Config</a>
				<a class="permalink" href="godoc.252.html#Config">&#xb6;</a>
				
				
			</h2>
			<p>
Config contains configuration data common to both ServerConfig and
ClientConfig.
</p>

			<pre>type Config struct {
<span id="Config.Rand"></span>    <span class="comment">// Rand provides the source of entropy for cryptographic</span>
    <span class="comment">// primitives. If Rand is nil, the cryptographic random reader</span>
    <span class="comment">// in package crypto/rand will be used.</span>
    Rand <a href="godoc.585.html">io</a>.<a href="godoc.585.html#Reader">Reader</a>

    <span class="comment">// The maximum number of bytes sent or received after which a</span>
    <span class="comment">// new key is negotiated. It must be at least 256. If</span>
    <span class="comment">// unspecified, a size suitable for the chosen cipher is used.</span>
<span id="Config.RekeyThreshold"></span>    RekeyThreshold <a href="godoc.4.html#uint64">uint64</a>

    <span class="comment">// The allowed key exchanges algorithms. If unspecified then a</span>
    <span class="comment">// default set of algorithms is used.</span>
<span id="Config.KeyExchanges"></span>    KeyExchanges []<a href="godoc.4.html#string">string</a>

    <span class="comment">// The allowed cipher algorithms. If unspecified then a sensible</span>
    <span class="comment">// default is used.</span>
<span id="Config.Ciphers"></span>    Ciphers []<a href="godoc.4.html#string">string</a>

    <span class="comment">// The allowed MAC algorithms. If unspecified then a sensible default</span>
    <span class="comment">// is used.</span>
<span id="Config.MACs"></span>    MACs []<a href="godoc.4.html#string">string</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Config.SetDefaults">func (*Config) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/common.go?s=7252:7282#L230">SetDefaults</a>
					<a class="permalink" href="godoc.252.html#Config.SetDefaults">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="godoc.252.html#Config">Config</a>) SetDefaults()</pre>
				<p>
SetDefaults sets sensible values for unset fields in config. This is
exported for testing: Configs passed to SSH functions are copied and have
default values set automatically.
</p>

				
				
				
			
		
			
			
			<h2 id="Conn">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/connection.go?s=1317:2204#L40">Conn</a>
				<a class="permalink" href="godoc.252.html#Conn">&#xb6;</a>
				
				
			</h2>
			<p>
Conn represents an SSH connection for both server and client roles.
Conn is the basis for implementing an application layer, such
as ClientConn, which implements the traditional shell access for
clients.
</p>

			<pre>type Conn interface {
    <a href="godoc.252.html#ConnMetadata">ConnMetadata</a>

    <span class="comment">// SendRequest sends a global request, and returns the</span>
    <span class="comment">// reply. If wantReply is true, it returns the response status</span>
    <span class="comment">// and payload. See also RFC4254, section 4.</span>
    SendRequest(name <a href="godoc.4.html#string">string</a>, wantReply <a href="godoc.4.html#bool">bool</a>, payload []<a href="godoc.4.html#byte">byte</a>) (<a href="godoc.4.html#bool">bool</a>, []<a href="godoc.4.html#byte">byte</a>, <a href="godoc.4.html#error">error</a>)

    <span class="comment">// OpenChannel tries to open an channel. If the request is</span>
    <span class="comment">// rejected, it returns *OpenChannelError. On success it returns</span>
    <span class="comment">// the SSH Channel and a Go channel for incoming, out-of-band</span>
    <span class="comment">// requests. The Go channel must be serviced, or the</span>
    <span class="comment">// connection will hang.</span>
    OpenChannel(name <a href="godoc.4.html#string">string</a>, data []<a href="godoc.4.html#byte">byte</a>) (<a href="godoc.252.html#Channel">Channel</a>, &lt;-chan *<a href="godoc.252.html#Request">Request</a>, <a href="godoc.4.html#error">error</a>)

    <span class="comment">// Close closes the underlying network connection</span>
    Close() <a href="godoc.4.html#error">error</a>

    <span class="comment">// Wait blocks until the connection has shut down, and returns the</span>
    <span class="comment">// error causing the shutdown.</span>
    Wait() <a href="godoc.4.html#error">error</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewClientConn">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client.go?s=1816:1931#L61">NewClientConn</a>
					<a class="permalink" href="godoc.252.html#NewClientConn">&#xb6;</a>
					
					
				</h3>
				<pre>func NewClientConn(c <a href="godoc.14.html">net</a>.<a href="godoc.14.html#Conn">Conn</a>, addr <a href="godoc.4.html#string">string</a>, config *<a href="godoc.252.html#ClientConfig">ClientConfig</a>) (<a href="godoc.252.html#Conn">Conn</a>, &lt;-chan <a href="godoc.252.html#NewChannel">NewChannel</a>, &lt;-chan *<a href="godoc.252.html#Request">Request</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
NewClientConn establishes an authenticated SSH connection using c
as the underlying transport.  The Request and NewChannel channels
must be serviced or the connection will hang.
</p>

				
				
			

			
		
			
			
			<h2 id="ConnMetadata">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/connection.go?s=524:1099#L14">ConnMetadata</a>
				<a class="permalink" href="godoc.252.html#ConnMetadata">&#xb6;</a>
				
				
			</h2>
			<p>
ConnMetadata holds metadata for the connection.
</p>

			<pre>type ConnMetadata interface {
    <span class="comment">// User returns the user ID for this connection.</span>
    User() <a href="godoc.4.html#string">string</a>

    <span class="comment">// SessionID returns the session hash, also denoted by H.</span>
    SessionID() []<a href="godoc.4.html#byte">byte</a>

    <span class="comment">// ClientVersion returns the client&#39;s version string as hashed</span>
    <span class="comment">// into the session ID.</span>
    ClientVersion() []<a href="godoc.4.html#byte">byte</a>

    <span class="comment">// ServerVersion returns the server&#39;s version string as hashed</span>
    <span class="comment">// into the session ID.</span>
    ServerVersion() []<a href="godoc.4.html#byte">byte</a>

    <span class="comment">// RemoteAddr returns the remote address for this connection.</span>
    RemoteAddr() <a href="godoc.14.html">net</a>.<a href="godoc.14.html#Addr">Addr</a>

    <span class="comment">// LocalAddr returns the local address for this connection.</span>
    LocalAddr() <a href="godoc.14.html">net</a>.<a href="godoc.14.html#Addr">Addr</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="CryptoPublicKey">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=8053:8123#L290">CryptoPublicKey</a>
				<a class="permalink" href="godoc.252.html#CryptoPublicKey">&#xb6;</a>
				
				
			</h2>
			<p>
CryptoPublicKey, if implemented by a PublicKey,
returns the underlying crypto.PublicKey form of the key.
</p>

			<pre>type CryptoPublicKey interface {
    CryptoPublicKey() <a href="godoc.148.html">crypto</a>.<a href="godoc.148.html#PublicKey">PublicKey</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ExitError">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=14431:14465#L590">ExitError</a>
				<a class="permalink" href="godoc.252.html#ExitError">&#xb6;</a>
				
				
			</h2>
			<p>
An ExitError reports unsuccessful completion of a remote command.
</p>

			<pre>type ExitError struct {
    <a href="godoc.252.html#Waitmsg">Waitmsg</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ExitError.Error">func (*ExitError) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=14467:14501#L594">Error</a>
					<a class="permalink" href="godoc.252.html#ExitError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="godoc.252.html#ExitError">ExitError</a>) Error() <a href="godoc.4.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ExitMissingError">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=11303:11333#L463">ExitMissingError</a>
				<a class="permalink" href="godoc.252.html#ExitMissingError">&#xb6;</a>
				
				
			</h2>
			<p>
ExitMissingError is returned if a session is torn down cleanly, but
the server sends no confirmation of the exit status.
</p>

			<pre>type ExitMissingError struct{}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ExitMissingError.Error">func (*ExitMissingError) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=11335:11376#L465">Error</a>
					<a class="permalink" href="godoc.252.html#ExitMissingError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="godoc.252.html#ExitMissingError">ExitMissingError</a>) Error() <a href="godoc.4.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="GSSAPIClient">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/ssh_gss.go?s=371:2400#L9">GSSAPIClient</a>
				<a class="permalink" href="godoc.252.html#GSSAPIClient">&#xb6;</a>
				
				
			</h2>
			<p>
GSSAPIClient provides the API to plug-in GSSAPI authentication for client logins.
</p>

			<pre>type GSSAPIClient interface {
    <span class="comment">// InitSecContext initiates the establishment of a security context for GSS-API between the</span>
    <span class="comment">// ssh client and ssh server. Initially the token parameter should be specified as nil.</span>
    <span class="comment">// The routine may return a outputToken which should be transferred to</span>
    <span class="comment">// the ssh server, where the ssh server will present it to</span>
    <span class="comment">// AcceptSecContext. If no token need be sent, InitSecContext will indicate this by setting</span>
    <span class="comment">// needContinue to false. To complete the context</span>
    <span class="comment">// establishment, one or more reply tokens may be required from the ssh</span>
    <span class="comment">// server;if so, InitSecContext will return a needContinue which is true.</span>
    <span class="comment">// In this case, InitSecContext should be called again when the</span>
    <span class="comment">// reply token is received from the ssh server, passing the reply</span>
    <span class="comment">// token to InitSecContext via the token parameters.</span>
    <span class="comment">// See RFC 2743 section 2.2.1 and RFC 4462 section 3.4.</span>
    InitSecContext(target <a href="godoc.4.html#string">string</a>, token []<a href="godoc.4.html#byte">byte</a>, isGSSDelegCreds <a href="godoc.4.html#bool">bool</a>) (outputToken []<a href="godoc.4.html#byte">byte</a>, needContinue <a href="godoc.4.html#bool">bool</a>, err <a href="godoc.4.html#error">error</a>)
    <span class="comment">// GetMIC generates a cryptographic MIC for the SSH2 message, and places</span>
    <span class="comment">// the MIC in a token for transfer to the ssh server.</span>
    <span class="comment">// The contents of the MIC field are obtained by calling GSS_GetMIC()</span>
    <span class="comment">// over the following, using the GSS-API context that was just</span>
    <span class="comment">// established:</span>
    <span class="comment">//  string    session identifier</span>
    <span class="comment">//  byte      SSH_MSG_USERAUTH_REQUEST</span>
    <span class="comment">//  string    user name</span>
    <span class="comment">//  string    service</span>
    <span class="comment">//  string    &#34;gssapi-with-mic&#34;</span>
    <span class="comment">// See RFC 2743 section 2.3.1 and RFC 4462 3.5.</span>
    GetMIC(micFiled []<a href="godoc.4.html#byte">byte</a>) ([]<a href="godoc.4.html#byte">byte</a>, <a href="godoc.4.html#error">error</a>)
    <span class="comment">// Whenever possible, it should be possible for</span>
    <span class="comment">// DeleteSecContext() calls to be successfully processed even</span>
    <span class="comment">// if other calls cannot succeed, thereby enabling context-related</span>
    <span class="comment">// resources to be released.</span>
    <span class="comment">// In addition to deleting established security contexts,</span>
    <span class="comment">// gss_delete_sec_context must also be able to delete &#34;half-built&#34;</span>
    <span class="comment">// security contexts resulting from an incomplete sequence of</span>
    <span class="comment">// InitSecContext()/AcceptSecContext() calls.</span>
    <span class="comment">// See RFC 2743 section 2.2.3.</span>
    DeleteSecContext() <a href="godoc.4.html#error">error</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="GSSAPIServer">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/ssh_gss.go?s=2487:4222#L48">GSSAPIServer</a>
				<a class="permalink" href="godoc.252.html#GSSAPIServer">&#xb6;</a>
				
				
			</h2>
			<p>
GSSAPIServer provides the API to plug in GSSAPI authentication for server logins.
</p>

			<pre>type GSSAPIServer interface {
    <span class="comment">// AcceptSecContext allows a remotely initiated security context between the application</span>
    <span class="comment">// and a remote peer to be established by the ssh client. The routine may return a</span>
    <span class="comment">// outputToken which should be transferred to the ssh client,</span>
    <span class="comment">// where the ssh client will present it to InitSecContext.</span>
    <span class="comment">// If no token need be sent, AcceptSecContext will indicate this</span>
    <span class="comment">// by setting the needContinue to false. To</span>
    <span class="comment">// complete the context establishment, one or more reply tokens may be</span>
    <span class="comment">// required from the ssh client. if so, AcceptSecContext</span>
    <span class="comment">// will return a needContinue which is true, in which case it</span>
    <span class="comment">// should be called again when the reply token is received from the ssh</span>
    <span class="comment">// client, passing the token to AcceptSecContext via the</span>
    <span class="comment">// token parameters.</span>
    <span class="comment">// The srcName return value is the authenticated username.</span>
    <span class="comment">// See RFC 2743 section 2.2.2 and RFC 4462 section 3.4.</span>
    AcceptSecContext(token []<a href="godoc.4.html#byte">byte</a>) (outputToken []<a href="godoc.4.html#byte">byte</a>, srcName <a href="godoc.4.html#string">string</a>, needContinue <a href="godoc.4.html#bool">bool</a>, err <a href="godoc.4.html#error">error</a>)
    <span class="comment">// VerifyMIC verifies that a cryptographic MIC, contained in the token parameter,</span>
    <span class="comment">// fits the supplied message is received from the ssh client.</span>
    <span class="comment">// See RFC 2743 section 2.3.2.</span>
    VerifyMIC(micField []<a href="godoc.4.html#byte">byte</a>, micToken []<a href="godoc.4.html#byte">byte</a>) <a href="godoc.4.html#error">error</a>
    <span class="comment">// Whenever possible, it should be possible for</span>
    <span class="comment">// DeleteSecContext() calls to be successfully processed even</span>
    <span class="comment">// if other calls cannot succeed, thereby enabling context-related</span>
    <span class="comment">// resources to be released.</span>
    <span class="comment">// In addition to deleting established security contexts,</span>
    <span class="comment">// gss_delete_sec_context must also be able to delete &#34;half-built&#34;</span>
    <span class="comment">// security contexts resulting from an incomplete sequence of</span>
    <span class="comment">// InitSecContext()/AcceptSecContext() calls.</span>
    <span class="comment">// See RFC 2743 section 2.2.3.</span>
    DeleteSecContext() <a href="godoc.4.html#error">error</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="GSSAPIWithMICConfig">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/server.go?s=1844:2624#L38">GSSAPIWithMICConfig</a>
				<a class="permalink" href="godoc.252.html#GSSAPIWithMICConfig">&#xb6;</a>
				
				
			</h2>
			
			<pre>type GSSAPIWithMICConfig struct {
<span id="GSSAPIWithMICConfig.AllowLogin"></span>    <span class="comment">// AllowLogin, must be set, is called when gssapi-with-mic</span>
    <span class="comment">// authentication is selected (RFC 4462 section 3). The srcName is from the</span>
    <span class="comment">// results of the GSS-API authentication. The format is username@DOMAIN.</span>
    <span class="comment">// GSSAPI just guarantees to the server who the user is, but not if they can log in, and with what permissions.</span>
    <span class="comment">// This callback is called after the user identity is established with GSSAPI to decide if the user can login with</span>
    <span class="comment">// which permissions. If the user is allowed to login, it should return a nil error.</span>
    AllowLogin func(conn <a href="godoc.252.html#ConnMetadata">ConnMetadata</a>, srcName <a href="godoc.4.html#string">string</a>) (*<a href="godoc.252.html#Permissions">Permissions</a>, <a href="godoc.4.html#error">error</a>)

<span id="GSSAPIWithMICConfig.Server"></span>    <span class="comment">// Server must be set. It&#39;s the implementation</span>
    <span class="comment">// of the GSSAPIServer interface. See GSSAPIServer interface for details.</span>
    Server <a href="godoc.252.html#GSSAPIServer">GSSAPIServer</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="HostKeyCallback">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client.go?s=5383:5463#L179">HostKeyCallback</a>
				<a class="permalink" href="godoc.252.html#HostKeyCallback">&#xb6;</a>
				
				
			</h2>
			<p>
HostKeyCallback is the function type used for verifying server
keys.  A HostKeyCallback must return nil if the host key is OK, or
an error to reject it. It receives the hostname as passed to Dial
or NewClientConn. The remote address is the RemoteAddr of the
net.Conn underlying the SSH connection.
</p>

			<pre>type HostKeyCallback func(hostname <a href="godoc.4.html#string">string</a>, remote <a href="godoc.14.html">net</a>.<a href="godoc.14.html#Addr">Addr</a>, key <a href="godoc.252.html#PublicKey">PublicKey</a>) <a href="godoc.4.html#error">error</a></pre>

			

			

			
			
			

			
				
				<h3 id="FixedHostKey">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client.go?s=8163:8211#L255">FixedHostKey</a>
					<a class="permalink" href="godoc.252.html#FixedHostKey">&#xb6;</a>
					
					
				</h3>
				<pre>func FixedHostKey(key <a href="godoc.252.html#PublicKey">PublicKey</a>) <a href="godoc.252.html#HostKeyCallback">HostKeyCallback</a></pre>
				<p>
FixedHostKey returns a function for use in
ClientConfig.HostKeyCallback to accept only a specific host key.
</p>

				
				
			
				
				<h3 id="InsecureIgnoreHostKey">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client.go?s=7591:7635#L233">InsecureIgnoreHostKey</a>
					<a class="permalink" href="godoc.252.html#InsecureIgnoreHostKey">&#xb6;</a>
					
					
				</h3>
				<pre>func InsecureIgnoreHostKey() <a href="godoc.252.html#HostKeyCallback">HostKeyCallback</a></pre>
				<p>
InsecureIgnoreHostKey returns a function that can be used for
ClientConfig.HostKeyCallback to accept any host key. It should
not be used for production code.
</p>

				
				
			

			
		
			
			
			<h2 id="KeyboardInteractiveChallenge">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/client_auth.go?s=10249:10377#L374">KeyboardInteractiveChallenge</a>
				<a class="permalink" href="godoc.252.html#KeyboardInteractiveChallenge">&#xb6;</a>
				
				
			</h2>
			<p>
KeyboardInteractiveChallenge should print questions, optionally
disabling echoing (e.g. for passwords), and return all the answers.
Challenge may be called multiple times in a single session. After
successful authentication, the server may send a challenge with no
questions, for which the user and instruction messages should be
printed.  RFC 4256 section 3.3 details how the UI should behave for
both CLI and GUI environments.
</p>

			<pre>type KeyboardInteractiveChallenge func(user, instruction <a href="godoc.4.html#string">string</a>, questions []<a href="godoc.4.html#string">string</a>, echos []<a href="godoc.4.html#bool">bool</a>) (answers []<a href="godoc.4.html#string">string</a>, err <a href="godoc.4.html#error">error</a>)</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="NewChannel">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/channel.go?s=679:1374#L18">NewChannel</a>
				<a class="permalink" href="godoc.252.html#NewChannel">&#xb6;</a>
				
				
			</h2>
			<p>
NewChannel represents an incoming request to a channel. It must either be
accepted for use by calling Accept, or rejected by calling Reject.
</p>

			<pre>type NewChannel interface {
    <span class="comment">// Accept accepts the channel creation request. It returns the Channel</span>
    <span class="comment">// and a Go channel containing SSH requests. The Go channel must be</span>
    <span class="comment">// serviced otherwise the Channel will hang.</span>
    Accept() (<a href="godoc.252.html#Channel">Channel</a>, &lt;-chan *<a href="godoc.252.html#Request">Request</a>, <a href="godoc.4.html#error">error</a>)

    <span class="comment">// Reject rejects the channel creation request. After calling</span>
    <span class="comment">// this, no other methods on the Channel may be called.</span>
    Reject(reason <a href="godoc.252.html#RejectionReason">RejectionReason</a>, message <a href="godoc.4.html#string">string</a>) <a href="godoc.4.html#error">error</a>

    <span class="comment">// ChannelType returns the type of the channel, as supplied by the</span>
    <span class="comment">// client.</span>
    ChannelType() <a href="godoc.4.html#string">string</a>

    <span class="comment">// ExtraData returns the arbitrary payload for this channel, as supplied</span>
    <span class="comment">// by the client. This data is specific to the channel type.</span>
    ExtraData() []<a href="godoc.4.html#byte">byte</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="OpenChannelError">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/connection.go?s=284:357#L4">OpenChannelError</a>
				<a class="permalink" href="godoc.252.html#OpenChannelError">&#xb6;</a>
				
				
			</h2>
			<p>
OpenChannelError is returned if the other side rejects an
OpenChannel request.
</p>

			<pre>type OpenChannelError struct {
<span id="OpenChannelError.Reason"></span>    Reason  <a href="godoc.252.html#RejectionReason">RejectionReason</a>
<span id="OpenChannelError.Message"></span>    Message <a href="godoc.4.html#string">string</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="OpenChannelError.Error">func (*OpenChannelError) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/connection.go?s=359:400#L9">Error</a>
					<a class="permalink" href="godoc.252.html#OpenChannelError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="godoc.252.html#OpenChannelError">OpenChannelError</a>) Error() <a href="godoc.4.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Permissions">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/server.go?s=567:1842#L11">Permissions</a>
				<a class="permalink" href="godoc.252.html#Permissions">&#xb6;</a>
				
				
			</h2>
			<p>
The Permissions type holds fine-grained permissions that are
specific to a user or a specific authentication method for a user.
The Permissions value for a successful authentication attempt is
available in ServerConn, so it can be used to pass information from
the user-authentication phase to the application layer.
</p>

			<pre>type Permissions struct {
<span id="Permissions.CriticalOptions"></span>    <span class="comment">// CriticalOptions indicate restrictions to the default</span>
    <span class="comment">// permissions, and are typically used in conjunction with</span>
    <span class="comment">// user certificates. The standard for SSH certificates</span>
    <span class="comment">// defines &#34;force-command&#34; (only allow the given command to</span>
    <span class="comment">// execute) and &#34;source-address&#34; (only allow connections from</span>
    <span class="comment">// the given address). The SSH package currently only enforces</span>
    <span class="comment">// the &#34;source-address&#34; critical option. It is up to server</span>
    <span class="comment">// implementations to enforce other critical options, such as</span>
    <span class="comment">// &#34;force-command&#34;, by checking them after the SSH handshake</span>
    <span class="comment">// is successful. In general, SSH servers should reject</span>
    <span class="comment">// connections that specify critical options that are unknown</span>
    <span class="comment">// or not supported.</span>
    CriticalOptions map[<a href="godoc.4.html#string">string</a>]<a href="godoc.4.html#string">string</a>

<span id="Permissions.Extensions"></span>    <span class="comment">// Extensions are extra functionality that the server may</span>
    <span class="comment">// offer on authenticated connections. Lack of support for an</span>
    <span class="comment">// extension does not preclude authenticating a user. Common</span>
    <span class="comment">// extensions are &#34;permit-agent-forwarding&#34;,</span>
    <span class="comment">// &#34;permit-X11-forwarding&#34;. The Go SSH library currently does</span>
    <span class="comment">// not act on any extension, and it is up to server</span>
    <span class="comment">// implementations to honor them. Extensions can be used to</span>
    <span class="comment">// pass data from the authentication callbacks to the server</span>
    <span class="comment">// application layer.</span>
    Extensions map[<a href="godoc.4.html#string">string</a>]<a href="godoc.4.html#string">string</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="PublicKey">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=7499:7940#L274">PublicKey</a>
				<a class="permalink" href="godoc.252.html#PublicKey">&#xb6;</a>
				
				
			</h2>
			<p>
PublicKey is an abstraction of different types of public keys.
</p>

			<pre>type PublicKey interface {
    <span class="comment">// Type returns the key&#39;s type, e.g. &#34;ssh-rsa&#34;.</span>
    Type() <a href="godoc.4.html#string">string</a>

    <span class="comment">// Marshal returns the serialized key data in SSH wire format,</span>
    <span class="comment">// with the name prefix. To unmarshal the returned data, use</span>
    <span class="comment">// the ParsePublicKey function.</span>
    Marshal() []<a href="godoc.4.html#byte">byte</a>

    <span class="comment">// Verify that sig is a signature on the given data using this</span>
    <span class="comment">// key. This function will hash the data appropriately first.</span>
    Verify(data []<a href="godoc.4.html#byte">byte</a>, sig *<a href="godoc.252.html#Signature">Signature</a>) <a href="godoc.4.html#error">error</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewPublicKey">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=20867:20920#L811">NewPublicKey</a>
					<a class="permalink" href="godoc.252.html#NewPublicKey">&#xb6;</a>
					
					
				</h3>
				<pre>func NewPublicKey(key interface{}) (<a href="godoc.252.html#PublicKey">PublicKey</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
NewPublicKey takes an *rsa.PublicKey, *dsa.PublicKey, *ecdsa.PublicKey,
or ed25519.PublicKey returns a corresponding PublicKey instance.
ECDSA keys must use P-256, P-384 or P-521.
</p>

				
				
			
				
				<h3 id="ParseAuthorizedKey">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=5018:5126#L164">ParseAuthorizedKey</a>
					<a class="permalink" href="godoc.252.html#ParseAuthorizedKey">&#xb6;</a>
					
					
				</h3>
				<pre>func ParseAuthorizedKey(in []<a href="godoc.4.html#byte">byte</a>) (out <a href="godoc.252.html#PublicKey">PublicKey</a>, comment <a href="godoc.4.html#string">string</a>, options []<a href="godoc.4.html#string">string</a>, rest []<a href="godoc.4.html#byte">byte</a>, err <a href="godoc.4.html#error">error</a>)</pre>
				<p>
ParseAuthorizedKeys parses a public key from an authorized_keys
file used in OpenSSH according to the sshd(8) manual page.
</p>

				
				
			
				
				<h3 id="ParseKnownHosts">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=3408:3529#L104">ParseKnownHosts</a>
					<a class="permalink" href="godoc.252.html#ParseKnownHosts">&#xb6;</a>
					
					
				</h3>
				<pre>func ParseKnownHosts(in []<a href="godoc.4.html#byte">byte</a>) (marker <a href="godoc.4.html#string">string</a>, hosts []<a href="godoc.4.html#string">string</a>, pubKey <a href="godoc.252.html#PublicKey">PublicKey</a>, comment <a href="godoc.4.html#string">string</a>, rest []<a href="godoc.4.html#byte">byte</a>, err <a href="godoc.4.html#error">error</a>)</pre>
				<p>
ParseKnownHosts parses an entry in the format of the known_hosts file.
</p>
<p>
The known_hosts format is documented in the sshd(8) manual page. This
function will parse a single entry from in. On successful return, marker
will contain the optional marker value (i.e. &#34;cert-authority&#34; or &#34;revoked&#34;)
or else be empty, hosts will contain the hosts that this entry matches,
pubKey will contain the public key and comment will contain any trailing
comment at the end of the line. See the sshd(8) manual page for the various
forms that a host string can take.
</p>
<p>
The unparsed remainder of the input will be returned in rest. This function
can be called repeatedly to parse multiple entries.
</p>
<p>
If no entries were found in the input then err will be io.EOF. Otherwise a
non-nil err value indicates a parse error.
</p>

				
				
			
				
				<h3 id="ParsePublicKey">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=6763:6820#L246">ParsePublicKey</a>
					<a class="permalink" href="godoc.252.html#ParsePublicKey">&#xb6;</a>
					
					
				</h3>
				<pre>func ParsePublicKey(in []<a href="godoc.4.html#byte">byte</a>) (out <a href="godoc.252.html#PublicKey">PublicKey</a>, err <a href="godoc.4.html#error">error</a>)</pre>
				<p>
ParsePublicKey parses an SSH public key formatted for use in
the SSH wire protocol according to RFC 4253, section 6.6.
</p>

				
				
			

			
		
			
			
			<h2 id="RejectionReason">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/channel.go?s=3394:3421#L100">RejectionReason</a>
				<a class="permalink" href="godoc.252.html#RejectionReason">&#xb6;</a>
				
				
			</h2>
			<p>
RejectionReason is an enumeration used when rejecting channel creation
requests. See RFC 4254, section 5.1.
</p>

			<pre>type RejectionReason <a href="godoc.4.html#uint32">uint32</a></pre>

			
				
				<pre>const (
    <span id="Prohibited">Prohibited</span> <a href="godoc.252.html#RejectionReason">RejectionReason</a> = <a href="godoc.4.html#iota">iota</a> + 1
    <span id="ConnectionFailed">ConnectionFailed</span>
    <span id="UnknownChannelType">UnknownChannelType</span>
    <span id="ResourceShortage">ResourceShortage</span>
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="RejectionReason.String">func (RejectionReason) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/channel.go?s=3593:3633#L110">String</a>
					<a class="permalink" href="godoc.252.html#RejectionReason.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="godoc.252.html#RejectionReason">RejectionReason</a>) String() <a href="godoc.4.html#string">string</a></pre>
				<p>
String converts the rejection reason to human readable form.
</p>

				
				
				
			
		
			
			
			<h2 id="Request">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/channel.go?s=2788:2888#L74">Request</a>
				<a class="permalink" href="godoc.252.html#Request">&#xb6;</a>
				
				
			</h2>
			<p>
Request is a request sent outside of the normal stream of
data. Requests can either be specific to an SSH channel, or they
can be global.
</p>

			<pre>type Request struct {
<span id="Request.Type"></span>    Type      <a href="godoc.4.html#string">string</a>
<span id="Request.WantReply"></span>    WantReply <a href="godoc.4.html#bool">bool</a>
<span id="Request.Payload"></span>    Payload   []<a href="godoc.4.html#byte">byte</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Request.Reply">func (*Request) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/channel.go?s=3095:3149#L86">Reply</a>
					<a class="permalink" href="godoc.252.html#Request.Reply">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="godoc.252.html#Request">Request</a>) Reply(ok <a href="godoc.4.html#bool">bool</a>, payload []<a href="godoc.4.html#byte">byte</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
Reply sends a response to a request. It must be called for all requests
where WantReply is true and is a no-op otherwise. The payload argument is
ignored for replies to channel-specific requests.
</p>

				
				
				
			
		
			
			
			<h2 id="ServerAuthError">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/server.go?s=12972:13154#L367">ServerAuthError</a>
				<a class="permalink" href="godoc.252.html#ServerAuthError">&#xb6;</a>
				
				
			</h2>
			<p>
ServerAuthError represents server authentication errors and is
sometimes returned by NewServerConn. It appends any authentication
errors that may occur, and is returned if all of the authentication
methods provided by the user failed to authenticate.
</p>

			<pre>type ServerAuthError struct {
<span id="ServerAuthError.Errors"></span>    <span class="comment">// Errors contains authentication errors returned by the authentication</span>
    <span class="comment">// callback methods. The first entry is typically ErrNoAuth.</span>
    Errors []<a href="godoc.4.html#error">error</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ServerAuthError.Error">func (ServerAuthError) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/server.go?s=13156:13195#L373">Error</a>
					<a class="permalink" href="godoc.252.html#ServerAuthError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (l <a href="godoc.252.html#ServerAuthError">ServerAuthError</a>) Error() <a href="godoc.4.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ServerConfig">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/server.go?s=2684:5178#L53">ServerConfig</a>
				<a class="permalink" href="godoc.252.html#ServerConfig">&#xb6;</a>
				
				
			</h2>
			<p>
ServerConfig holds server specific configuration data.
</p>

			<pre>type ServerConfig struct {
    <span class="comment">// Config contains configuration shared between client and server.</span>
    <a href="godoc.252.html#Config">Config</a>

<span id="ServerConfig.NoClientAuth"></span>    <span class="comment">// NoClientAuth is true if clients are allowed to connect without</span>
    <span class="comment">// authenticating.</span>
    NoClientAuth <a href="godoc.4.html#bool">bool</a>

<span id="ServerConfig.MaxAuthTries"></span>    <span class="comment">// MaxAuthTries specifies the maximum number of authentication attempts</span>
    <span class="comment">// permitted per connection. If set to a negative number, the number of</span>
    <span class="comment">// attempts are unlimited. If set to zero, the number of attempts are limited</span>
    <span class="comment">// to 6.</span>
    MaxAuthTries <a href="godoc.4.html#int">int</a>

<span id="ServerConfig.PasswordCallback"></span>    <span class="comment">// PasswordCallback, if non-nil, is called when a user</span>
    <span class="comment">// attempts to authenticate using a password.</span>
    PasswordCallback func(conn <a href="godoc.252.html#ConnMetadata">ConnMetadata</a>, password []<a href="godoc.4.html#byte">byte</a>) (*<a href="godoc.252.html#Permissions">Permissions</a>, <a href="godoc.4.html#error">error</a>)

<span id="ServerConfig.PublicKeyCallback"></span>    <span class="comment">// PublicKeyCallback, if non-nil, is called when a client</span>
    <span class="comment">// offers a public key for authentication. It must return a nil error</span>
    <span class="comment">// if the given public key can be used to authenticate the</span>
    <span class="comment">// given user. For example, see CertChecker.Authenticate. A</span>
    <span class="comment">// call to this function does not guarantee that the key</span>
    <span class="comment">// offered is in fact used to authenticate. To record any data</span>
    <span class="comment">// depending on the public key, store it inside a</span>
    <span class="comment">// Permissions.Extensions entry.</span>
    PublicKeyCallback func(conn <a href="godoc.252.html#ConnMetadata">ConnMetadata</a>, key <a href="godoc.252.html#PublicKey">PublicKey</a>) (*<a href="godoc.252.html#Permissions">Permissions</a>, <a href="godoc.4.html#error">error</a>)

<span id="ServerConfig.KeyboardInteractiveCallback"></span>    <span class="comment">// KeyboardInteractiveCallback, if non-nil, is called when</span>
    <span class="comment">// keyboard-interactive authentication is selected (RFC</span>
    <span class="comment">// 4256). The client object&#39;s Challenge function should be</span>
    <span class="comment">// used to query the user. The callback may offer multiple</span>
    <span class="comment">// Challenge rounds. To avoid information leaks, the client</span>
    <span class="comment">// should be presented a challenge even if the user is</span>
    <span class="comment">// unknown.</span>
    KeyboardInteractiveCallback func(conn <a href="godoc.252.html#ConnMetadata">ConnMetadata</a>, client <a href="godoc.252.html#KeyboardInteractiveChallenge">KeyboardInteractiveChallenge</a>) (*<a href="godoc.252.html#Permissions">Permissions</a>, <a href="godoc.4.html#error">error</a>)

<span id="ServerConfig.AuthLogCallback"></span>    <span class="comment">// AuthLogCallback, if non-nil, is called to log all authentication</span>
    <span class="comment">// attempts.</span>
    AuthLogCallback func(conn <a href="godoc.252.html#ConnMetadata">ConnMetadata</a>, method <a href="godoc.4.html#string">string</a>, err <a href="godoc.4.html#error">error</a>)

<span id="ServerConfig.ServerVersion"></span>    <span class="comment">// ServerVersion is the version identification string to announce in</span>
    <span class="comment">// the public handshake.</span>
    <span class="comment">// If empty, a reasonable default is used.</span>
    <span class="comment">// Note that RFC 4253 section 4.2 requires that this string start with</span>
    <span class="comment">// &#34;SSH-2.0-&#34;.</span>
    ServerVersion <a href="godoc.4.html#string">string</a>

<span id="ServerConfig.BannerCallback"></span>    <span class="comment">// BannerCallback, if present, is called and the return string is sent to</span>
    <span class="comment">// the client after key exchange completed but before authentication.</span>
    BannerCallback func(conn <a href="godoc.252.html#ConnMetadata">ConnMetadata</a>) <a href="godoc.4.html#string">string</a>

<span id="ServerConfig.GSSAPIWithMICConfig"></span>    <span class="comment">// GSSAPIWithMICConfig includes gssapi server and callback, which if both non-nil, is used</span>
    <span class="comment">// when gssapi-with-mic authentication is selected (RFC 4462 section 3).</span>
    GSSAPIWithMICConfig *<a href="godoc.252.html#GSSAPIWithMICConfig">GSSAPIWithMICConfig</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ServerConfig.AddHostKey">func (*ServerConfig) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/server.go?s=5361:5406#L115">AddHostKey</a>
					<a class="permalink" href="godoc.252.html#ServerConfig.AddHostKey">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#ServerConfig">ServerConfig</a>) AddHostKey(key <a href="godoc.252.html#Signer">Signer</a>)</pre>
				<p>
AddHostKey adds a private key as a host key. If an existing host
key exists with the same algorithm, it is overwritten. Each server
config must have at least one host key.
</p>

				
				
				
			
		
			
			
			<h2 id="ServerConn">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/server.go?s=6674:6842#L164">ServerConn</a>
				<a class="permalink" href="godoc.252.html#ServerConn">&#xb6;</a>
				
				
			</h2>
			<p>
ServerConn is an authenticated SSH connection, as seen from the
server
</p>

			<pre>type ServerConn struct {
    <a href="godoc.252.html#Conn">Conn</a>

    <span class="comment">// If the succeeding authentication callback returned a</span>
    <span class="comment">// non-nil Permissions pointer, it is stored here.</span>
<span id="ServerConn.Permissions"></span>    Permissions *<a href="godoc.252.html#Permissions">Permissions</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewServerConn">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/server.go?s=7218:7327#L180">NewServerConn</a>
					<a class="permalink" href="godoc.252.html#NewServerConn">&#xb6;</a>
					
					
				</h3>
				<pre>func NewServerConn(c <a href="godoc.14.html">net</a>.<a href="godoc.14.html#Conn">Conn</a>, config *<a href="godoc.252.html#ServerConfig">ServerConfig</a>) (*<a href="godoc.252.html#ServerConn">ServerConn</a>, &lt;-chan <a href="godoc.252.html#NewChannel">NewChannel</a>, &lt;-chan *<a href="godoc.252.html#Request">Request</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
NewServerConn starts a new SSH server with c as the underlying
transport.  It starts with a handshake and, if the handshake is
unsuccessful, it closes the connection and returns an error.  The
Request and NewChannel channels must be serviced, or the connection
will hang.
</p>
<p>
The returned error may be of type *ServerAuthError for
authentication errors.
</p>

				<div id="example_NewServerConn" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Public key authentication is done by comparing</span>
<span class="comment">// the public key of a received connection</span>
<span class="comment">// with the entries in the authorized_keys file.</span>
authorizedKeysBytes, err := ioutil.ReadFile(&#34;authorized_keys&#34;)
if err != nil {
    log.Fatalf(&#34;Failed to load authorized_keys, err: %v&#34;, err)
}

authorizedKeysMap := map[string]bool{}
for len(authorizedKeysBytes) &gt; 0 {
    pubKey, _, _, rest, err := ssh.ParseAuthorizedKey(authorizedKeysBytes)
    if err != nil {
        log.Fatal(err)
    }

    authorizedKeysMap[string(pubKey.Marshal())] = true
    authorizedKeysBytes = rest
}

<span class="comment">// An SSH server is represented by a ServerConfig, which holds</span>
<span class="comment">// certificate details and handles authentication of ServerConns.</span>
config := &amp;ssh.ServerConfig{
    <span class="comment">// Remove to disable password auth.</span>
    PasswordCallback: func(c ssh.ConnMetadata, pass []byte) (*ssh.Permissions, error) {
        <span class="comment">// Should use constant-time compare (or better, salt+hash) in</span>
        <span class="comment">// a production setting.</span>
        if c.User() == &#34;testuser&#34; &amp;&amp; string(pass) == &#34;tiger&#34; {
            return nil, nil
        }
        return nil, fmt.Errorf(&#34;password rejected for %q&#34;, c.User())
    },

    <span class="comment">// Remove to disable public key auth.</span>
    PublicKeyCallback: func(c ssh.ConnMetadata, pubKey ssh.PublicKey) (*ssh.Permissions, error) {
        if authorizedKeysMap[string(pubKey.Marshal())] {
            return &amp;ssh.Permissions{
                <span class="comment">// Record the public key used for authentication.</span>
                Extensions: map[string]string{
                    &#34;pubkey-fp&#34;: ssh.FingerprintSHA256(pubKey),
                },
            }, nil
        }
        return nil, fmt.Errorf(&#34;unknown public key for %q&#34;, c.User())
    },
}

privateBytes, err := ioutil.ReadFile(&#34;id_rsa&#34;)
if err != nil {
    log.Fatal(&#34;Failed to load private key: &#34;, err)
}

private, err := ssh.ParsePrivateKey(privateBytes)
if err != nil {
    log.Fatal(&#34;Failed to parse private key: &#34;, err)
}

config.AddHostKey(private)

<span class="comment">// Once a ServerConfig has been configured, connections can be</span>
<span class="comment">// accepted.</span>
listener, err := net.Listen(&#34;tcp&#34;, &#34;0.0.0.0:2022&#34;)
if err != nil {
    log.Fatal(&#34;failed to listen for connection: &#34;, err)
}
nConn, err := listener.Accept()
if err != nil {
    log.Fatal(&#34;failed to accept incoming connection: &#34;, err)
}

<span class="comment">// Before use, a handshake must be performed on the incoming</span>
<span class="comment">// net.Conn.</span>
conn, chans, reqs, err := ssh.NewServerConn(nConn, config)
if err != nil {
    log.Fatal(&#34;failed to handshake: &#34;, err)
}
log.Printf(&#34;logged in with key %s&#34;, conn.Permissions.Extensions[&#34;pubkey-fp&#34;])

<span class="comment">// The incoming Request channel must be serviced.</span>
go ssh.DiscardRequests(reqs)

<span class="comment">// Service the incoming Channel channel.</span>
for newChannel := range chans {
    <span class="comment">// Channels have a type, depending on the application level</span>
    <span class="comment">// protocol intended. In the case of a shell, the type is</span>
    <span class="comment">// &#34;session&#34; and ServerShell may be used to present a simple</span>
    <span class="comment">// terminal interface.</span>
    if newChannel.ChannelType() != &#34;session&#34; {
        newChannel.Reject(ssh.UnknownChannelType, &#34;unknown channel type&#34;)
        continue
    }
    channel, requests, err := newChannel.Accept()
    if err != nil {
        log.Fatalf(&#34;Could not accept channel: %v&#34;, err)
    }

    <span class="comment">// Sessions have out-of-band requests such as &#34;shell&#34;,</span>
    <span class="comment">// &#34;pty-req&#34; and &#34;env&#34;.  Here we handle only the</span>
    <span class="comment">// &#34;shell&#34; request.</span>
    go func(in &lt;-chan *ssh.Request) {
        for req := range in {
            req.Reply(req.Type == &#34;shell&#34;, nil)
        }
    }(requests)

    term := terminal.NewTerminal(channel, &#34;&gt; &#34;)

    go func() {
        defer channel.Close()
        for {
            line, err := term.ReadLine()
            if err != nil {
                break
            }
            fmt.Println(line)
        }
    }()
}
</pre>
			
		
	</div>
</div>

				
			

			
		
			
			
			<h2 id="Session">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=2216:3287#L106">Session</a>
				<a class="permalink" href="godoc.252.html#Session">&#xb6;</a>
				
				
			</h2>
			<p>
A Session represents a connection to a remote command or shell.
</p>

			<pre>type Session struct {
<span id="Session.Stdin"></span>    <span class="comment">// Stdin specifies the remote process&#39;s standard input.</span>
    <span class="comment">// If Stdin is nil, the remote process reads from an empty</span>
    <span class="comment">// bytes.Buffer.</span>
    Stdin <a href="godoc.585.html">io</a>.<a href="godoc.585.html#Reader">Reader</a>

<span id="Session.Stdout"></span>    <span class="comment">// Stdout and Stderr specify the remote process&#39;s standard</span>
    <span class="comment">// output and error.</span>
    <span class="comment">//</span>
    <span class="comment">// If either is nil, Run connects the corresponding file</span>
    <span class="comment">// descriptor to an instance of ioutil.Discard. There is a</span>
    <span class="comment">// fixed amount of buffering that is shared for the two streams.</span>
    <span class="comment">// If either blocks it may eventually cause the remote</span>
    <span class="comment">// command to block.</span>
    Stdout <a href="godoc.585.html">io</a>.<a href="godoc.585.html#Writer">Writer</a>
<span id="Session.Stderr"></span>    Stderr <a href="godoc.585.html">io</a>.<a href="godoc.585.html#Writer">Writer</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Session.Close">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=3532:3563#L145">Close</a>
					<a class="permalink" href="godoc.252.html#Session.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) Close() <a href="godoc.4.html#error">error</a></pre>
				
				
				
				
			
				
				<h3 id="Session.CombinedOutput">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=8080:8140#L331">CombinedOutput</a>
					<a class="permalink" href="godoc.252.html#Session.CombinedOutput">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) CombinedOutput(cmd <a href="godoc.4.html#string">string</a>) ([]<a href="godoc.4.html#byte">byte</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
CombinedOutput runs cmd on the remote host and returns its combined
standard output and standard error.
</p>

				
				
				
			
				
				<h3 id="Session.Output">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=7584:7636#L308">Output</a>
					<a class="permalink" href="godoc.252.html#Session.Output">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) Output(cmd <a href="godoc.4.html#string">string</a>) ([]<a href="godoc.4.html#byte">byte</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
Output runs cmd on the remote host and returns its standard output.
</p>

				
				
				
			
				
				<h3 id="Session.RequestPty">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=4271:4353#L180">RequestPty</a>
					<a class="permalink" href="godoc.252.html#Session.RequestPty">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) RequestPty(term <a href="godoc.4.html#string">string</a>, h, w <a href="godoc.4.html#int">int</a>, termmodes <a href="godoc.252.html#TerminalModes">TerminalModes</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
RequestPty requests the association of a pty with the session on the remote host.
</p>

				
				<div id="example_Session_RequestPty" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
var hostKey ssh.PublicKey
<span class="comment">// Create client config</span>
config := &amp;ssh.ClientConfig{
    User: &#34;username&#34;,
    Auth: []ssh.AuthMethod{
        ssh.Password(&#34;password&#34;),
    },
    HostKeyCallback: ssh.FixedHostKey(hostKey),
}
<span class="comment">// Connect to ssh server</span>
conn, err := ssh.Dial(&#34;tcp&#34;, &#34;localhost:22&#34;, config)
if err != nil {
    log.Fatal(&#34;unable to connect: &#34;, err)
}
defer conn.Close()
<span class="comment">// Create a session</span>
session, err := conn.NewSession()
if err != nil {
    log.Fatal(&#34;unable to create session: &#34;, err)
}
defer session.Close()
<span class="comment">// Set up terminal modes</span>
modes := ssh.TerminalModes{
    ssh.ECHO:          0,     <span class="comment">// disable echoing</span>
    ssh.TTY_OP_ISPEED: 14400, <span class="comment">// input speed = 14.4kbaud</span>
    ssh.TTY_OP_OSPEED: 14400, <span class="comment">// output speed = 14.4kbaud</span>
}
<span class="comment">// Request pseudo terminal</span>
if err := session.RequestPty(&#34;xterm&#34;, 40, 80, modes); err != nil {
    log.Fatal(&#34;request for pseudo terminal failed: &#34;, err)
}
<span class="comment">// Start remote shell</span>
if err := session.Shell(); err != nil {
    log.Fatal(&#34;failed to start shell: &#34;, err)
}
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Session.RequestSubsystem">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=5114:5172#L213">RequestSubsystem</a>
					<a class="permalink" href="godoc.252.html#Session.RequestSubsystem">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) RequestSubsystem(subsystem <a href="godoc.4.html#string">string</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
RequestSubsystem requests the association of a subsystem with the session on the remote host.
A subsystem is a predefined command that runs in the background when the ssh session is initiated
</p>

				
				
				
			
				
				<h3 id="Session.Run">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=7397:7436#L299">Run</a>
					<a class="permalink" href="godoc.252.html#Session.Run">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) Run(cmd <a href="godoc.4.html#string">string</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
Run runs cmd on the remote host. Typically, the remote
server passes cmd to the shell for interpretation.
A Session only accepts one call to Run, Start, Shell, Output,
or CombinedOutput.
</p>
<p>
The returned error is nil if the command runs, has no problems
copying stdin, stdout, and stderr, and exits with a zero exit
status.
</p>
<p>
If the remote server does not send an exit status, an error of type
*ExitMissingError is returned. If the command completes
unsuccessfully or is interrupted by a signal, the error is of type
*ExitError. Other error types may be returned for I/O problems.
</p>

				
				
				
			
				
				<h3 id="Session.SendRequest">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=3387:3475#L141">SendRequest</a>
					<a class="permalink" href="godoc.252.html#Session.SendRequest">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) SendRequest(name <a href="godoc.4.html#string">string</a>, wantReply <a href="godoc.4.html#bool">bool</a>, payload []<a href="godoc.4.html#byte">byte</a>) (<a href="godoc.4.html#bool">bool</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
SendRequest sends an out-of-band channel request on the SSH channel
underlying the session.
</p>

				
				
				
			
				
				<h3 id="Session.Setenv">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=3778:3828#L157">Setenv</a>
					<a class="permalink" href="godoc.252.html#Session.Setenv">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) Setenv(name, value <a href="godoc.4.html#string">string</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
Setenv sets an environment variable that will be applied to any
command executed by Shell or Run.
</p>

				
				
				
			
				
				<h3 id="Session.Shell">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=8528:8559#L347">Shell</a>
					<a class="permalink" href="godoc.252.html#Session.Shell">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) Shell() <a href="godoc.4.html#error">error</a></pre>
				<p>
Shell starts a login shell on the remote host. A Session only
accepts one call to Run, Start, Shell, Output, or CombinedOutput.
</p>

				
				
				
			
				
				<h3 id="Session.Signal">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=6037:6079#L251">Signal</a>
					<a class="permalink" href="godoc.252.html#Session.Signal">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) Signal(sig <a href="godoc.252.html#Signal">Signal</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
Signal sends the given signal to the remote process.
sig is one of the SIG* constants.
</p>

				
				
				
			
				
				<h3 id="Session.Start">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=6442:6483#L268">Start</a>
					<a class="permalink" href="godoc.252.html#Session.Start">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) Start(cmd <a href="godoc.4.html#string">string</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
Start runs cmd on the remote host. Typically, the remote
server passes cmd to the shell for interpretation.
A Session only accepts one call to Run, Start or Shell.
</p>

				
				
				
			
				
				<h3 id="Session.StderrPipe">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=13826:13875#L565">StderrPipe</a>
					<a class="permalink" href="godoc.252.html#Session.StderrPipe">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) StderrPipe() (<a href="godoc.585.html">io</a>.<a href="godoc.585.html#Reader">Reader</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
StderrPipe returns a pipe that will be connected to the
remote command&#39;s standard error when the command starts.
There is a fixed amount of buffering that is shared between
stdout and stderr streams. If the StderrPipe reader is
not serviced fast enough it may eventually cause the
remote command to block.
</p>

				
				
				
			
				
				<h3 id="Session.StdinPipe">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=12644:12697#L531">StdinPipe</a>
					<a class="permalink" href="godoc.252.html#Session.StdinPipe">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) StdinPipe() (<a href="godoc.585.html">io</a>.<a href="godoc.585.html#WriteCloser">WriteCloser</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
StdinPipe returns a pipe that will be connected to the
remote command&#39;s standard input when the command starts.
</p>

				
				
				
			
				
				<h3 id="Session.StdoutPipe">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=13246:13295#L548">StdoutPipe</a>
					<a class="permalink" href="godoc.252.html#Session.StdoutPipe">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) StdoutPipe() (<a href="godoc.585.html">io</a>.<a href="godoc.585.html#Reader">Reader</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
StdoutPipe returns a pipe that will be connected to the
remote command&#39;s standard output when the command starts.
There is a fixed amount of buffering that is shared between
stdout and stderr streams. If the StdoutPipe reader is
not serviced fast enough it may eventually cause the
remote command to block.
</p>

				
				
				
			
				
				<h3 id="Session.Wait">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=9611:9641#L389">Wait</a>
					<a class="permalink" href="godoc.252.html#Session.Wait">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) Wait() <a href="godoc.4.html#error">error</a></pre>
				<p>
Wait waits for the remote command to exit.
</p>
<p>
The returned error is nil if the command runs, has no problems
copying stdin, stdout, and stderr, and exits with a zero exit
status.
</p>
<p>
If the remote server does not send an exit status, an error of type
*ExitMissingError is returned. If the command completes
unsuccessfully or is interrupted by a signal, the error is of type
*ExitError. Other error types may be returned for I/O problems.
</p>

				
				
				
			
				
				<h3 id="Session.WindowChange">func (*Session) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=5619:5665#L233">WindowChange</a>
					<a class="permalink" href="godoc.252.html#Session.WindowChange">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="godoc.252.html#Session">Session</a>) WindowChange(h, w <a href="godoc.4.html#int">int</a>) <a href="godoc.4.html#error">error</a></pre>
				<p>
WindowChange informs the remote host about a terminal window dimension change to h rows and w columns.
</p>

				
				
				
			
		
			
			
			<h2 id="Signal">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=342:360#L10">Signal</a>
				<a class="permalink" href="godoc.252.html#Signal">&#xb6;</a>
				
				
			</h2>
			
			<pre>type Signal <a href="godoc.4.html#string">string</a></pre>

			
				<p>
POSIX signals as listed in RFC 4254 Section 6.10.
</p>

				<pre>const (
    <span id="SIGABRT">SIGABRT</span> <a href="godoc.252.html#Signal">Signal</a> = &#34;ABRT&#34;
    <span id="SIGALRM">SIGALRM</span> <a href="godoc.252.html#Signal">Signal</a> = &#34;ALRM&#34;
    <span id="SIGFPE">SIGFPE</span>  <a href="godoc.252.html#Signal">Signal</a> = &#34;FPE&#34;
    <span id="SIGHUP">SIGHUP</span>  <a href="godoc.252.html#Signal">Signal</a> = &#34;HUP&#34;
    <span id="SIGILL">SIGILL</span>  <a href="godoc.252.html#Signal">Signal</a> = &#34;ILL&#34;
    <span id="SIGINT">SIGINT</span>  <a href="godoc.252.html#Signal">Signal</a> = &#34;INT&#34;
    <span id="SIGKILL">SIGKILL</span> <a href="godoc.252.html#Signal">Signal</a> = &#34;KILL&#34;
    <span id="SIGPIPE">SIGPIPE</span> <a href="godoc.252.html#Signal">Signal</a> = &#34;PIPE&#34;
    <span id="SIGQUIT">SIGQUIT</span> <a href="godoc.252.html#Signal">Signal</a> = &#34;QUIT&#34;
    <span id="SIGSEGV">SIGSEGV</span> <a href="godoc.252.html#Signal">Signal</a> = &#34;SEGV&#34;
    <span id="SIGTERM">SIGTERM</span> <a href="godoc.252.html#Signal">Signal</a> = &#34;TERM&#34;
    <span id="SIGUSR1">SIGUSR1</span> <a href="godoc.252.html#Signal">Signal</a> = &#34;USR1&#34;
    <span id="SIGUSR2">SIGUSR2</span> <a href="godoc.252.html#Signal">Signal</a> = &#34;USR2&#34;
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="Signature">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/certs.go?s=966:1021#L27">Signature</a>
				<a class="permalink" href="godoc.252.html#Signature">&#xb6;</a>
				
				
			</h2>
			<p>
Signature represents a cryptographic signature.
</p>

			<pre>type Signature struct {
<span id="Signature.Format"></span>    Format <a href="godoc.4.html#string">string</a>
<span id="Signature.Blob"></span>    Blob   []<a href="godoc.4.html#byte">byte</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Signer">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=8193:8479#L295">Signer</a>
				<a class="permalink" href="godoc.252.html#Signer">&#xb6;</a>
				
				
			</h2>
			<p>
A Signer can create signatures that verify against a public key.
</p>

			<pre>type Signer interface {
    <span class="comment">// PublicKey returns an associated PublicKey instance.</span>
    PublicKey() <a href="godoc.252.html#PublicKey">PublicKey</a>

    <span class="comment">// Sign returns raw signature for the given data. This method</span>
    <span class="comment">// will apply the hash specified for the keytype to the data.</span>
    Sign(rand <a href="godoc.585.html">io</a>.<a href="godoc.585.html#Reader">Reader</a>, data []<a href="godoc.4.html#byte">byte</a>) (*<a href="godoc.252.html#Signature">Signature</a>, <a href="godoc.4.html#error">error</a>)
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewCertSigner">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/certs.go?s=5731:5799#L223">NewCertSigner</a>
					<a class="permalink" href="godoc.252.html#NewCertSigner">&#xb6;</a>
					
					
				</h3>
				<pre>func NewCertSigner(cert *<a href="godoc.252.html#Certificate">Certificate</a>, signer <a href="godoc.252.html#Signer">Signer</a>) (<a href="godoc.252.html#Signer">Signer</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
NewCertSigner returns a Signer that signs with the given Certificate, whose
private key is held by signer. It returns an error if the public key in cert
doesn&#39;t match the key used by signer.
</p>

				
				
			
				
				<h3 id="NewSignerFromKey">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=17512:17566#L682">NewSignerFromKey</a>
					<a class="permalink" href="godoc.252.html#NewSignerFromKey">&#xb6;</a>
					
					
				</h3>
				<pre>func NewSignerFromKey(key interface{}) (<a href="godoc.252.html#Signer">Signer</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
NewSignerFromKey takes an *rsa.PrivateKey, *dsa.PrivateKey,
*ecdsa.PrivateKey or any other crypto.Signer and returns a
corresponding Signer instance. ECDSA keys must use P-256, P-384 or
P-521. DSA keys must use parameter size L1024N160.
</p>

				
				
			
				
				<h3 id="NewSignerFromSigner">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=18222:18284#L709">NewSignerFromSigner</a>
					<a class="permalink" href="godoc.252.html#NewSignerFromSigner">&#xb6;</a>
					
					
				</h3>
				<pre>func NewSignerFromSigner(signer <a href="godoc.148.html">crypto</a>.<a href="godoc.148.html#Signer">Signer</a>) (<a href="godoc.252.html#Signer">Signer</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
NewSignerFromSigner takes any crypto.Signer implementation and
returns a corresponding Signer interface. This can be used, for
example, with keys kept in hardware modules.
</p>

				
				
			
				
				<h3 id="ParsePrivateKey">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=21517:21570#L831">ParsePrivateKey</a>
					<a class="permalink" href="godoc.252.html#ParsePrivateKey">&#xb6;</a>
					
					
				</h3>
				<pre>func ParsePrivateKey(pemBytes []<a href="godoc.4.html#byte">byte</a>) (<a href="godoc.252.html#Signer">Signer</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
ParsePrivateKey returns a Signer from a PEM encoded private key. It supports
the same keys as ParseRawPrivateKey.
</p>

				
				
			
				
				<h3 id="ParsePrivateKeyWithPassphrase">func <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/keys.go?s=21853:21932#L843">ParsePrivateKeyWithPassphrase</a>
					<a class="permalink" href="godoc.252.html#ParsePrivateKeyWithPassphrase">&#xb6;</a>
					
					
				</h3>
				<pre>func ParsePrivateKeyWithPassphrase(pemBytes, passPhrase []<a href="godoc.4.html#byte">byte</a>) (<a href="godoc.252.html#Signer">Signer</a>, <a href="godoc.4.html#error">error</a>)</pre>
				<p>
ParsePrivateKeyWithPassphrase returns a Signer from a PEM encoded private
key and passphrase. It supports the same keys as
ParseRawPrivateKeyWithPassphrase.
</p>

				
				
			

			
		
			
			
			<h2 id="TerminalModes">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=927:962#L43">TerminalModes</a>
				<a class="permalink" href="godoc.252.html#TerminalModes">&#xb6;</a>
				
				
			</h2>
			
			<pre>type TerminalModes map[<a href="godoc.4.html#uint8">uint8</a>]<a href="godoc.4.html#uint32">uint32</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Waitmsg">type <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=14623:14703#L600">Waitmsg</a>
				<a class="permalink" href="godoc.252.html#Waitmsg">&#xb6;</a>
				
				
			</h2>
			<p>
Waitmsg stores the information about an exited remote command
as reported by Wait.
</p>

			<pre>type Waitmsg struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Waitmsg.ExitStatus">func (Waitmsg) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=14766:14799#L608">ExitStatus</a>
					<a class="permalink" href="godoc.252.html#Waitmsg.ExitStatus">&#xb6;</a>
					
					
				</h3>
				<pre>func (w <a href="godoc.252.html#Waitmsg">Waitmsg</a>) ExitStatus() <a href="godoc.4.html#int">int</a></pre>
				<p>
ExitStatus returns the exit status of the remote command.
</p>

				
				
				
			
				
				<h3 id="Waitmsg.Lang">func (Waitmsg) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=15124:15154#L624">Lang</a>
					<a class="permalink" href="godoc.252.html#Waitmsg.Lang">&#xb6;</a>
					
					
				</h3>
				<pre>func (w <a href="godoc.252.html#Waitmsg">Waitmsg</a>) Lang() <a href="godoc.4.html#string">string</a></pre>
				<p>
Lang returns the language tag. See RFC 3066
</p>

				
				
				
			
				
				<h3 id="Waitmsg.Msg">func (Waitmsg) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=15028:15057#L619">Msg</a>
					<a class="permalink" href="godoc.252.html#Waitmsg.Msg">&#xb6;</a>
					
					
				</h3>
				<pre>func (w <a href="godoc.252.html#Waitmsg">Waitmsg</a>) Msg() <a href="godoc.4.html#string">string</a></pre>
				<p>
Msg returns the exit message given by the remote command
</p>

				
				
				
			
				
				<h3 id="Waitmsg.Signal">func (Waitmsg) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=14913:14945#L614">Signal</a>
					<a class="permalink" href="godoc.252.html#Waitmsg.Signal">&#xb6;</a>
					
					
				</h3>
				<pre>func (w <a href="godoc.252.html#Waitmsg">Waitmsg</a>) Signal() <a href="godoc.4.html#string">string</a></pre>
				<p>
Signal returns the exit signal of the remote command if
it was terminated violently.
</p>

				
				
				
			
				
				<h3 id="Waitmsg.String">func (Waitmsg) <a href="http://localhost:6161/src/golang.org/x/crypto/ssh/session.go?s=15175:15207#L628">String</a>
					<a class="permalink" href="godoc.252.html#Waitmsg.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (w <a href="godoc.252.html#Waitmsg">Waitmsg</a>) String() <a href="godoc.4.html#string">string</a></pre>
				
				
				
				
			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="godoc.208.html">..</a></td>
			</tr>
			

			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="godoc.253.html">agent</a>
					</td>
				
					<td class="pkg-synopsis">
						Package agent implements the ssh-agent protocol, and provides both a client and a server.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="godoc.254.html">knownhosts</a>
					</td>
				
					<td class="pkg-synopsis">
						Package knownhosts implements a parser for the OpenSSH known_hosts host key database, and provides utility functions for writing OpenSSH compliant known_hosts files.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="godoc.255.html">terminal</a>
					</td>
				
					<td class="pkg-synopsis">
						Package terminal provides support functions for dealing with terminals, as commonly found on UNIX systems.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="godoc.256.html">test</a>
					</td>
				
					<td class="pkg-synopsis">
						Package test contains integration tests for the golang.org/x/crypto/ssh package.
					</td>
				</tr>
			
		</table>
	</div>



<div id="footer">
Build version go1.13.5.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6161/LICENSE">BSD license</a>.<br>
<a href="http://localhost:6161/doc/tos.html">Terms of Service</a> |
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
